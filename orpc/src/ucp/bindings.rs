/* automatically generated by rust-bindgen 0.66.1 */

#![allow(warnings)]

pub const UCS_ALLOCA_MAX_SIZE: u32 = 1200;
pub const UCT_COMPONENT_NAME_MAX: u32 = 16;
pub const UCT_MD_GLOBAL_ID_MAX: u32 = 256;
pub const UCT_TL_NAME_MAX: u32 = 10;
pub const UCT_MD_NAME_MAX: u32 = 16;
pub const UCT_DEVICE_NAME_MAX: u32 = 32;
pub const UCT_PENDING_REQ_PRIV_LEN: u32 = 40;
pub const UCT_TAG_PRIV_LEN: u32 = 32;
pub const UCT_AM_ID_BITS: u32 = 5;
pub const UCT_DMABUF_FD_INVALID: i32 = -1;
pub const UCS_CALLBACKQ_FAST_COUNT: u32 = 7;
pub const UCS_CALLBACKQ_ID_NULL: i32 = -1;
pub const UCT_VERNO_MAJOR: u32 = 1;
pub const UCT_VERNO_MINOR: u32 = 14;
pub const UCT_VERNO_PATCH: u32 = 1;
pub const UCT_VERNO_EXTRA: &[u8; 1] = b"\0";
pub const UCT_VERNO_STRING: &[u8; 7] = b"1.14.1\0";
pub const UCT_SCM_VERSION: &[u8; 8] = b"04897a0\0";
pub const UCT_SCM_BRANCH: &[u8; 1] = b"\0";
pub const UCT_MINOR_BIT: u32 = 16;
pub const UCT_MAJOR_BIT: u32 = 24;
pub const UCT_API: u32 = 17694720;
pub const UCS_CPU_SETSIZE: u32 = 1024;
pub const UCS_SYS_DEVICE_ID_MAX: u32 = 255;
pub const UCS_SYS_DEVICE_ID_UNKNOWN: u32 = 255;
pub const UCS_SYS_BDF_NAME_MAX: u32 = 16;
pub const UCS_SYS_DEVICE_PRIORITY_TCP: u32 = 10;
pub const UCS_SYS_DEVICE_PRIORITY_IB: u32 = 20;
pub const UCS_SYS_DEVICE_PRIORITY_CUDA: u32 = 10;
pub const UCT_TL_RESOURCE_DESC_FMT: &[u8; 6] = b"%s/%s\0";
pub const UCP_ENTITY_NAME_MAX: u32 = 32;
pub const UCP_VERSION_MAJOR_SHIFT: u32 = 24;
pub const UCP_VERSION_MINOR_SHIFT: u32 = 16;
pub const UCP_API_MAJOR: u32 = 1;
pub const UCP_API_MINOR: u32 = 14;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type off_t = __off_t;
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_log_level_t {
    UCS_LOG_LEVEL_FATAL = 0,
    UCS_LOG_LEVEL_ERROR = 1,
    UCS_LOG_LEVEL_WARN = 2,
    UCS_LOG_LEVEL_DIAG = 3,
    UCS_LOG_LEVEL_INFO = 4,
    UCS_LOG_LEVEL_DEBUG = 5,
    UCS_LOG_LEVEL_TRACE = 6,
    UCS_LOG_LEVEL_TRACE_REQ = 7,
    UCS_LOG_LEVEL_TRACE_DATA = 8,
    UCS_LOG_LEVEL_TRACE_ASYNC = 9,
    UCS_LOG_LEVEL_TRACE_FUNC = 10,
    UCS_LOG_LEVEL_TRACE_POLL = 11,
    UCS_LOG_LEVEL_LAST = 12,
    UCS_LOG_LEVEL_PRINT = 13,
}
impl ucs_async_mode_t {
    pub const UCS_ASYNC_MODE_THREAD_SPINLOCK: ucs_async_mode_t =
        ucs_async_mode_t::UCS_ASYNC_MODE_THREAD;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_async_mode_t {
    UCS_ASYNC_MODE_SIGNAL = 0,
    UCS_ASYNC_MODE_THREAD = 1,
    UCS_ASYNC_MODE_THREAD_MUTEX = 2,
    UCS_ASYNC_MODE_POLL = 3,
    UCS_ASYNC_MODE_LAST = 4,
}
extern "C" {
    pub static mut ucs_async_mode_names: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_ternary_auto_value {
    UCS_NO = 0,
    UCS_YES = 1,
    UCS_TRY = 2,
    UCS_AUTO = 3,
    UCS_TERNARY_LAST = 4,
}
pub use self::ucs_ternary_auto_value as ucs_ternary_auto_value_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_on_off_auto_value {
    UCS_CONFIG_OFF = 0,
    UCS_CONFIG_ON = 1,
    UCS_CONFIG_AUTO = 2,
    UCS_CONFIG_ON_OFF_LAST = 3,
}
pub use self::ucs_on_off_auto_value as ucs_on_off_auto_value_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_handle_error_t {
    UCS_HANDLE_ERROR_BACKTRACE = 0,
    UCS_HANDLE_ERROR_FREEZE = 1,
    UCS_HANDLE_ERROR_DEBUG = 2,
    UCS_HANDLE_ERROR_NONE = 3,
    UCS_HANDLE_ERROR_LAST = 4,
}
impl ucs_config_print_flags_t {
    pub const UCS_CONFIG_PRINT_CONFIG: ucs_config_print_flags_t = ucs_config_print_flags_t(1);
}
impl ucs_config_print_flags_t {
    pub const UCS_CONFIG_PRINT_HEADER: ucs_config_print_flags_t = ucs_config_print_flags_t(2);
}
impl ucs_config_print_flags_t {
    pub const UCS_CONFIG_PRINT_DOC: ucs_config_print_flags_t = ucs_config_print_flags_t(4);
}
impl ucs_config_print_flags_t {
    pub const UCS_CONFIG_PRINT_HIDDEN: ucs_config_print_flags_t = ucs_config_print_flags_t(8);
}
impl ucs_config_print_flags_t {
    pub const UCS_CONFIG_PRINT_COMMENT_DEFAULT: ucs_config_print_flags_t =
        ucs_config_print_flags_t(16);
}
impl ::std::ops::BitOr<ucs_config_print_flags_t> for ucs_config_print_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucs_config_print_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucs_config_print_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucs_config_print_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucs_config_print_flags_t> for ucs_config_print_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucs_config_print_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucs_config_print_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucs_config_print_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucs_config_print_flags_t(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_config_names_array_t {
    pub names: *mut *mut ::std::os::raw::c_char,
    pub count: ::std::os::raw::c_uint,
    pub pad: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ucs_config_names_array_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_config_names_array_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_config_names_array_t>(),
        16usize,
        concat!("Size of: ", stringify!(ucs_config_names_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_config_names_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_config_names_array_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_config_names_array_t),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_config_names_array_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_config_names_array_t),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_config_allow_list_mode_t {
    UCS_CONFIG_ALLOW_LIST_ALLOW_ALL = 0,
    UCS_CONFIG_ALLOW_LIST_ALLOW = 1,
    UCS_CONFIG_ALLOW_LIST_NEGATE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_config_allow_list_t {
    pub array: ucs_config_names_array_t,
    pub mode: ucs_config_allow_list_mode_t,
}
#[test]
fn bindgen_test_layout_ucs_config_allow_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_config_allow_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_config_allow_list_t>(),
        24usize,
        concat!("Size of: ", stringify!(ucs_config_allow_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_config_allow_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_config_allow_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_config_allow_list_t),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_config_allow_list_t),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_sock_addr {
    pub addr: *const sockaddr,
    pub addrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_ucs_sock_addr() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_sock_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_sock_addr>(),
        16usize,
        concat!("Size of: ", stringify!(ucs_sock_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_sock_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_sock_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sock_addr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addrlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sock_addr),
            "::",
            stringify!(addrlen)
        )
    );
}
pub type ucs_sock_addr_t = ucs_sock_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_log_component_config {
    pub log_level: ucs_log_level_t,
    pub name: [::std::os::raw::c_char; 16usize],
    pub file_filter: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ucs_log_component_config() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_log_component_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_log_component_config>(),
        32usize,
        concat!("Size of: ", stringify!(ucs_log_component_config))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_log_component_config>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_log_component_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_log_component_config),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_log_component_config),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_filter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_log_component_config),
            "::",
            stringify!(file_filter)
        )
    );
}
pub type ucs_log_component_config_t = ucs_log_component_config;
#[repr(i8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_status_t {
    UCS_OK = 0,
    UCS_INPROGRESS = 1,
    UCS_ERR_NO_MESSAGE = -1,
    UCS_ERR_NO_RESOURCE = -2,
    UCS_ERR_IO_ERROR = -3,
    UCS_ERR_NO_MEMORY = -4,
    UCS_ERR_INVALID_PARAM = -5,
    UCS_ERR_UNREACHABLE = -6,
    UCS_ERR_INVALID_ADDR = -7,
    UCS_ERR_NOT_IMPLEMENTED = -8,
    UCS_ERR_MESSAGE_TRUNCATED = -9,
    UCS_ERR_NO_PROGRESS = -10,
    UCS_ERR_BUFFER_TOO_SMALL = -11,
    UCS_ERR_NO_ELEM = -12,
    UCS_ERR_SOME_CONNECTS_FAILED = -13,
    UCS_ERR_NO_DEVICE = -14,
    UCS_ERR_BUSY = -15,
    UCS_ERR_CANCELED = -16,
    UCS_ERR_SHMEM_SEGMENT = -17,
    UCS_ERR_ALREADY_EXISTS = -18,
    UCS_ERR_OUT_OF_RANGE = -19,
    UCS_ERR_TIMED_OUT = -20,
    UCS_ERR_EXCEEDS_LIMIT = -21,
    UCS_ERR_UNSUPPORTED = -22,
    UCS_ERR_REJECTED = -23,
    UCS_ERR_NOT_CONNECTED = -24,
    UCS_ERR_CONNECTION_RESET = -25,
    UCS_ERR_FIRST_LINK_FAILURE = -40,
    UCS_ERR_LAST_LINK_FAILURE = -59,
    UCS_ERR_FIRST_ENDPOINT_FAILURE = -60,
    UCS_ERR_ENDPOINT_TIMEOUT = -80,
    UCS_ERR_LAST_ENDPOINT_FAILURE = -89,
    UCS_ERR_LAST = -100,
}
pub type ucs_status_ptr_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn ucs_status_string(status: ucs_status_t) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_am_trace_type {
    UCT_AM_TRACE_TYPE_SEND = 0,
    UCT_AM_TRACE_TYPE_RECV = 1,
    UCT_AM_TRACE_TYPE_SEND_DROP = 2,
    UCT_AM_TRACE_TYPE_RECV_DROP = 3,
    UCT_AM_TRACE_TYPE_LAST = 4,
}
impl uct_cb_param_flags {
    pub const UCT_CB_PARAM_FLAG_DESC: uct_cb_param_flags = uct_cb_param_flags(1);
}
impl uct_cb_param_flags {
    pub const UCT_CB_PARAM_FLAG_FIRST: uct_cb_param_flags = uct_cb_param_flags(2);
}
impl uct_cb_param_flags {
    pub const UCT_CB_PARAM_FLAG_MORE: uct_cb_param_flags = uct_cb_param_flags(4);
}
impl ::std::ops::BitOr<uct_cb_param_flags> for uct_cb_param_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cb_param_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cb_param_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cb_param_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cb_param_flags> for uct_cb_param_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cb_param_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cb_param_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cb_param_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cb_param_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_component {
    _unused: [u8; 0],
}
pub type uct_component_h = *mut uct_component;
pub type uct_iface_h = *mut uct_iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_config {
    _unused: [u8; 0],
}
pub type uct_iface_config_t = uct_iface_config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_md_config {
    _unused: [u8; 0],
}
pub type uct_md_config_t = uct_md_config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_config {
    _unused: [u8; 0],
}
pub type uct_cm_config_t = uct_cm_config;
pub type uct_ep_h = *mut uct_ep;
pub type uct_mem_h = *mut ::std::os::raw::c_void;
pub type uct_rkey_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_md {
    _unused: [u8; 0],
}
pub type uct_md_h = *mut uct_md;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_md_ops {
    _unused: [u8; 0],
}
pub type uct_md_ops_t = uct_md_ops;
pub type uct_rkey_ctx_h = *mut ::std::os::raw::c_void;
pub type uct_iface_attr_t = uct_iface_attr;
pub type uct_iface_params_t = uct_iface_params;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_ep_attr {
    _unused: [u8; 0],
}
pub type uct_ep_attr_t = uct_ep_attr;
pub type uct_md_attr_t = uct_md_attr;
pub type uct_completion_t = uct_completion;
pub type uct_pending_req_t = uct_pending_req;
pub type uct_worker_h = *mut uct_worker;
pub type uct_md_t = uct_md;
pub use self::uct_am_trace_type as uct_am_trace_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_device_addr {
    _unused: [u8; 0],
}
pub type uct_device_addr_t = uct_device_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_addr {
    _unused: [u8; 0],
}
pub type uct_iface_addr_t = uct_iface_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_ep_addr {
    _unused: [u8; 0],
}
pub type uct_ep_addr_t = uct_ep_addr;
pub type uct_ep_params_t = uct_ep_params;
pub type uct_ep_connect_params_t = uct_ep_connect_params;
pub type uct_cm_attr_t = uct_cm_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm {
    _unused: [u8; 0],
}
pub type uct_cm_t = uct_cm;
pub type uct_cm_h = *mut uct_cm_t;
pub type uct_listener_attr_t = uct_listener_attr;
pub type uct_listener_h = *mut uct_listener;
pub type uct_listener_params_t = uct_listener_params;
pub type uct_tag_context_t = uct_tag_context;
pub type uct_tag_t = u64;
pub type uct_worker_cb_id_t = ::std::os::raw::c_int;
pub type uct_conn_request_h = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iov {
    pub buffer: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub memh: uct_mem_h,
    pub stride: usize,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uct_iov() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iov> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iov>(),
        40usize,
        concat!("Size of: ", stringify!(uct_iov))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iov>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_iov))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iov),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iov),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memh) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iov),
            "::",
            stringify!(memh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iov),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iov),
            "::",
            stringify!(count)
        )
    );
}
pub type uct_iov_t = uct_iov;
impl uct_cm_ep_priv_data_pack_args_field {
    pub const UCT_CM_EP_PRIV_DATA_PACK_ARGS_FIELD_DEVICE_NAME: uct_cm_ep_priv_data_pack_args_field =
        uct_cm_ep_priv_data_pack_args_field(1);
}
impl ::std::ops::BitOr<uct_cm_ep_priv_data_pack_args_field>
    for uct_cm_ep_priv_data_pack_args_field
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cm_ep_priv_data_pack_args_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cm_ep_priv_data_pack_args_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cm_ep_priv_data_pack_args_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cm_ep_priv_data_pack_args_field>
    for uct_cm_ep_priv_data_pack_args_field
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cm_ep_priv_data_pack_args_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cm_ep_priv_data_pack_args_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cm_ep_priv_data_pack_args_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cm_ep_priv_data_pack_args_field(pub ::std::os::raw::c_uint);
impl uct_cm_ep_resolve_args_field {
    pub const UCT_CM_EP_RESOLVE_ARGS_FIELD_DEV_NAME: uct_cm_ep_resolve_args_field =
        uct_cm_ep_resolve_args_field(1);
}
impl uct_cm_ep_resolve_args_field {
    pub const UCT_CM_EP_RESOLVE_ARGS_FIELD_STATUS: uct_cm_ep_resolve_args_field =
        uct_cm_ep_resolve_args_field(2);
}
impl ::std::ops::BitOr<uct_cm_ep_resolve_args_field> for uct_cm_ep_resolve_args_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cm_ep_resolve_args_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cm_ep_resolve_args_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cm_ep_resolve_args_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cm_ep_resolve_args_field> for uct_cm_ep_resolve_args_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cm_ep_resolve_args_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cm_ep_resolve_args_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cm_ep_resolve_args_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cm_ep_resolve_args_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_ep_priv_data_pack_args {
    pub field_mask: u64,
    pub dev_name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_uct_cm_ep_priv_data_pack_args() {
    const UNINIT: ::std::mem::MaybeUninit<uct_cm_ep_priv_data_pack_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_cm_ep_priv_data_pack_args>(),
        40usize,
        concat!("Size of: ", stringify!(uct_cm_ep_priv_data_pack_args))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_cm_ep_priv_data_pack_args>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_cm_ep_priv_data_pack_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_priv_data_pack_args),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_priv_data_pack_args),
            "::",
            stringify!(dev_name)
        )
    );
}
pub type uct_cm_ep_priv_data_pack_args_t = uct_cm_ep_priv_data_pack_args;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_ep_resolve_args {
    pub field_mask: u64,
    pub dev_name: [::std::os::raw::c_char; 32usize],
    pub status: ucs_status_t,
}
#[test]
fn bindgen_test_layout_uct_cm_ep_resolve_args() {
    const UNINIT: ::std::mem::MaybeUninit<uct_cm_ep_resolve_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_cm_ep_resolve_args>(),
        48usize,
        concat!("Size of: ", stringify!(uct_cm_ep_resolve_args))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_cm_ep_resolve_args>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_cm_ep_resolve_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_resolve_args),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_resolve_args),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_resolve_args),
            "::",
            stringify!(status)
        )
    );
}
pub type uct_cm_ep_resolve_args_t = uct_cm_ep_resolve_args;
impl uct_cm_remote_data_field {
    pub const UCT_CM_REMOTE_DATA_FIELD_DEV_ADDR: uct_cm_remote_data_field =
        uct_cm_remote_data_field(1);
}
impl uct_cm_remote_data_field {
    pub const UCT_CM_REMOTE_DATA_FIELD_DEV_ADDR_LENGTH: uct_cm_remote_data_field =
        uct_cm_remote_data_field(2);
}
impl uct_cm_remote_data_field {
    pub const UCT_CM_REMOTE_DATA_FIELD_CONN_PRIV_DATA: uct_cm_remote_data_field =
        uct_cm_remote_data_field(4);
}
impl uct_cm_remote_data_field {
    pub const UCT_CM_REMOTE_DATA_FIELD_CONN_PRIV_DATA_LENGTH: uct_cm_remote_data_field =
        uct_cm_remote_data_field(8);
}
impl ::std::ops::BitOr<uct_cm_remote_data_field> for uct_cm_remote_data_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cm_remote_data_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cm_remote_data_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cm_remote_data_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cm_remote_data_field> for uct_cm_remote_data_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cm_remote_data_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cm_remote_data_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cm_remote_data_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cm_remote_data_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_remote_data {
    pub field_mask: u64,
    pub dev_addr: *const uct_device_addr_t,
    pub dev_addr_length: usize,
    pub conn_priv_data: *const ::std::os::raw::c_void,
    pub conn_priv_data_length: usize,
}
#[test]
fn bindgen_test_layout_uct_cm_remote_data() {
    const UNINIT: ::std::mem::MaybeUninit<uct_cm_remote_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_cm_remote_data>(),
        40usize,
        concat!("Size of: ", stringify!(uct_cm_remote_data))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_cm_remote_data>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_cm_remote_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_remote_data),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_remote_data),
            "::",
            stringify!(dev_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_addr_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_remote_data),
            "::",
            stringify!(dev_addr_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_priv_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_remote_data),
            "::",
            stringify!(conn_priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_priv_data_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_remote_data),
            "::",
            stringify!(conn_priv_data_length)
        )
    );
}
pub type uct_cm_remote_data_t = uct_cm_remote_data;
impl uct_cm_listener_conn_request_args_field {
    pub const UCT_CM_LISTENER_CONN_REQUEST_ARGS_FIELD_DEV_NAME:
        uct_cm_listener_conn_request_args_field = uct_cm_listener_conn_request_args_field(1);
}
impl uct_cm_listener_conn_request_args_field {
    pub const UCT_CM_LISTENER_CONN_REQUEST_ARGS_FIELD_CONN_REQUEST:
        uct_cm_listener_conn_request_args_field = uct_cm_listener_conn_request_args_field(2);
}
impl uct_cm_listener_conn_request_args_field {
    pub const UCT_CM_LISTENER_CONN_REQUEST_ARGS_FIELD_REMOTE_DATA:
        uct_cm_listener_conn_request_args_field = uct_cm_listener_conn_request_args_field(4);
}
impl uct_cm_listener_conn_request_args_field {
    pub const UCT_CM_LISTENER_CONN_REQUEST_ARGS_FIELD_CLIENT_ADDR:
        uct_cm_listener_conn_request_args_field = uct_cm_listener_conn_request_args_field(8);
}
impl ::std::ops::BitOr<uct_cm_listener_conn_request_args_field>
    for uct_cm_listener_conn_request_args_field
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cm_listener_conn_request_args_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cm_listener_conn_request_args_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cm_listener_conn_request_args_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cm_listener_conn_request_args_field>
    for uct_cm_listener_conn_request_args_field
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cm_listener_conn_request_args_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cm_listener_conn_request_args_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cm_listener_conn_request_args_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cm_listener_conn_request_args_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_listener_conn_request_args {
    pub field_mask: u64,
    pub dev_name: [::std::os::raw::c_char; 32usize],
    pub conn_request: uct_conn_request_h,
    pub remote_data: *const uct_cm_remote_data_t,
    pub client_address: ucs_sock_addr_t,
}
#[test]
fn bindgen_test_layout_uct_cm_listener_conn_request_args() {
    const UNINIT: ::std::mem::MaybeUninit<uct_cm_listener_conn_request_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_cm_listener_conn_request_args>(),
        72usize,
        concat!("Size of: ", stringify!(uct_cm_listener_conn_request_args))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_cm_listener_conn_request_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_cm_listener_conn_request_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_listener_conn_request_args),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_listener_conn_request_args),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_request) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_listener_conn_request_args),
            "::",
            stringify!(conn_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_listener_conn_request_args),
            "::",
            stringify!(remote_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_address) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_listener_conn_request_args),
            "::",
            stringify!(client_address)
        )
    );
}
pub type uct_cm_listener_conn_request_args_t = uct_cm_listener_conn_request_args;
impl uct_cm_ep_client_connect_args_field {
    pub const UCT_CM_EP_CLIENT_CONNECT_ARGS_FIELD_REMOTE_DATA: uct_cm_ep_client_connect_args_field =
        uct_cm_ep_client_connect_args_field(1);
}
impl uct_cm_ep_client_connect_args_field {
    pub const UCT_CM_EP_CLIENT_CONNECT_ARGS_FIELD_STATUS: uct_cm_ep_client_connect_args_field =
        uct_cm_ep_client_connect_args_field(2);
}
impl ::std::ops::BitOr<uct_cm_ep_client_connect_args_field>
    for uct_cm_ep_client_connect_args_field
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cm_ep_client_connect_args_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cm_ep_client_connect_args_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cm_ep_client_connect_args_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cm_ep_client_connect_args_field>
    for uct_cm_ep_client_connect_args_field
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cm_ep_client_connect_args_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cm_ep_client_connect_args_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cm_ep_client_connect_args_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cm_ep_client_connect_args_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_ep_client_connect_args {
    pub field_mask: u64,
    pub remote_data: *const uct_cm_remote_data_t,
    pub status: ucs_status_t,
}
#[test]
fn bindgen_test_layout_uct_cm_ep_client_connect_args() {
    const UNINIT: ::std::mem::MaybeUninit<uct_cm_ep_client_connect_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_cm_ep_client_connect_args>(),
        24usize,
        concat!("Size of: ", stringify!(uct_cm_ep_client_connect_args))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_cm_ep_client_connect_args>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_cm_ep_client_connect_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_client_connect_args),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_client_connect_args),
            "::",
            stringify!(remote_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_client_connect_args),
            "::",
            stringify!(status)
        )
    );
}
pub type uct_cm_ep_client_connect_args_t = uct_cm_ep_client_connect_args;
impl uct_cm_ep_server_conn_notify_args_field {
    pub const UCT_CM_EP_SERVER_CONN_NOTIFY_ARGS_FIELD_STATUS:
        uct_cm_ep_server_conn_notify_args_field = uct_cm_ep_server_conn_notify_args_field(1);
}
impl ::std::ops::BitOr<uct_cm_ep_server_conn_notify_args_field>
    for uct_cm_ep_server_conn_notify_args_field
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cm_ep_server_conn_notify_args_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cm_ep_server_conn_notify_args_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cm_ep_server_conn_notify_args_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cm_ep_server_conn_notify_args_field>
    for uct_cm_ep_server_conn_notify_args_field
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cm_ep_server_conn_notify_args_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cm_ep_server_conn_notify_args_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cm_ep_server_conn_notify_args_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cm_ep_server_conn_notify_args_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_ep_server_conn_notify_args {
    pub field_mask: u64,
    pub status: ucs_status_t,
}
#[test]
fn bindgen_test_layout_uct_cm_ep_server_conn_notify_args() {
    const UNINIT: ::std::mem::MaybeUninit<uct_cm_ep_server_conn_notify_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_cm_ep_server_conn_notify_args>(),
        16usize,
        concat!("Size of: ", stringify!(uct_cm_ep_server_conn_notify_args))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_cm_ep_server_conn_notify_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_cm_ep_server_conn_notify_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_server_conn_notify_args),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_ep_server_conn_notify_args),
            "::",
            stringify!(status)
        )
    );
}
pub type uct_cm_ep_server_conn_notify_args_t = uct_cm_ep_server_conn_notify_args;
pub type uct_am_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> ucs_status_t,
>;
pub type uct_am_tracer_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        type_: uct_am_trace_type_t,
        id: u8,
        data: *const ::std::os::raw::c_void,
        length: usize,
        buffer: *mut ::std::os::raw::c_char,
        max: usize,
    ),
>;
pub type uct_completion_callback_t =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut uct_completion_t)>;
pub type uct_pending_callback_t =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut uct_pending_req_t) -> ucs_status_t>;
pub type uct_error_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        ep: uct_ep_h,
        status: ucs_status_t,
    ) -> ucs_status_t,
>;
pub type uct_pending_purge_callback_t = ::std::option::Option<
    unsafe extern "C" fn(self_: *mut uct_pending_req_t, arg: *mut ::std::os::raw::c_void),
>;
pub type uct_pack_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
pub type uct_unpack_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_void,
        length: usize,
    ),
>;
pub type uct_sockaddr_conn_request_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        iface: uct_iface_h,
        arg: *mut ::std::os::raw::c_void,
        conn_request: uct_conn_request_h,
        conn_priv_data: *const ::std::os::raw::c_void,
        length: usize,
    ),
>;
pub type uct_cm_listener_conn_request_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        listener: uct_listener_h,
        arg: *mut ::std::os::raw::c_void,
        conn_req_args: *const uct_cm_listener_conn_request_args_t,
    ),
>;
pub type uct_cm_ep_server_conn_notify_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        arg: *mut ::std::os::raw::c_void,
        connect_args: *const uct_cm_ep_server_conn_notify_args_t,
    ),
>;
pub type uct_cm_ep_client_connect_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        arg: *mut ::std::os::raw::c_void,
        connect_args: *const uct_cm_ep_client_connect_args_t,
    ),
>;
pub type uct_ep_disconnect_cb_t =
    ::std::option::Option<unsafe extern "C" fn(ep: uct_ep_h, arg: *mut ::std::os::raw::c_void)>;
pub type uct_cm_ep_priv_data_pack_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        pack_args: *const uct_cm_ep_priv_data_pack_args_t,
        priv_data: *mut ::std::os::raw::c_void,
    ) -> isize,
>;
pub type uct_cm_ep_resolve_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        resolve_args: *const uct_cm_ep_resolve_args_t,
    ) -> ucs_status_t,
>;
pub type uct_tag_unexp_eager_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        length: usize,
        flags: ::std::os::raw::c_uint,
        stag: uct_tag_t,
        imm: u64,
        context: *mut *mut ::std::os::raw::c_void,
    ) -> ucs_status_t,
>;
pub type uct_tag_unexp_rndv_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
        stag: u64,
        header: *const ::std::os::raw::c_void,
        header_length: ::std::os::raw::c_uint,
        remote_addr: u64,
        length: usize,
        rkey_buf: *const ::std::os::raw::c_void,
    ) -> ucs_status_t,
>;
pub type uct_async_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, flags: ::std::os::raw::c_uint),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_list_link {
    pub prev: *mut ucs_list_link,
    pub next: *mut ucs_list_link,
}
#[test]
fn bindgen_test_layout_ucs_list_link() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_list_link> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_list_link>(),
        16usize,
        concat!("Size of: ", stringify!(ucs_list_link))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_list_link>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_list_link))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_list_link),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_list_link),
            "::",
            stringify!(next)
        )
    );
}
pub type ucs_list_link_t = ucs_list_link;
pub type ucs_callbackq_t = ucs_callbackq;
pub type ucs_callbackq_elem_t = ucs_callbackq_elem;
pub type ucs_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
pub type ucs_callbackq_predicate_t = ::std::option::Option<
    unsafe extern "C" fn(
        elem: *const ucs_callbackq_elem_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
impl ucs_callbackq_flags {
    pub const UCS_CALLBACKQ_FLAG_FAST: ucs_callbackq_flags = ucs_callbackq_flags(1);
}
impl ucs_callbackq_flags {
    pub const UCS_CALLBACKQ_FLAG_ONESHOT: ucs_callbackq_flags = ucs_callbackq_flags(2);
}
impl ::std::ops::BitOr<ucs_callbackq_flags> for ucs_callbackq_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucs_callbackq_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucs_callbackq_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucs_callbackq_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucs_callbackq_flags> for ucs_callbackq_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucs_callbackq_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucs_callbackq_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucs_callbackq_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucs_callbackq_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_callbackq_elem {
    pub cb: ucs_callback_t,
    pub arg: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ucs_callbackq_elem() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_callbackq_elem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_callbackq_elem>(),
        24usize,
        concat!("Size of: ", stringify!(ucs_callbackq_elem))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_callbackq_elem>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_callbackq_elem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_callbackq_elem),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_callbackq_elem),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_callbackq_elem),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_callbackq_elem),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_callbackq {
    pub fast_elems: [ucs_callbackq_elem_t; 8usize],
    pub priv_: [::std::os::raw::c_char; 72usize],
}
#[test]
fn bindgen_test_layout_ucs_callbackq() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_callbackq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_callbackq>(),
        264usize,
        concat!("Size of: ", stringify!(ucs_callbackq))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_callbackq>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_callbackq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fast_elems) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_callbackq),
            "::",
            stringify!(fast_elems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_callbackq),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn ucs_callbackq_init(cbq: *mut ucs_callbackq_t) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_callbackq_cleanup(cbq: *mut ucs_callbackq_t);
}
extern "C" {
    pub fn ucs_callbackq_add(
        cbq: *mut ucs_callbackq_t,
        cb: ucs_callback_t,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucs_callbackq_remove(cbq: *mut ucs_callbackq_t, id: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ucs_callbackq_add_safe(
        cbq: *mut ucs_callbackq_t,
        cb: ucs_callback_t,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucs_callbackq_remove_safe(cbq: *mut ucs_callbackq_t, id: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ucs_callbackq_remove_if(
        cbq: *mut ucs_callbackq_t,
        pred: ucs_callbackq_predicate_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub type uct_ep_put_short_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        buffer: *const ::std::os::raw::c_void,
        length: ::std::os::raw::c_uint,
        remote_addr: u64,
        rkey: uct_rkey_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_put_bcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        pack_cb: uct_pack_callback_t,
        arg: *mut ::std::os::raw::c_void,
        remote_addr: u64,
        rkey: uct_rkey_t,
    ) -> isize,
>;
pub type uct_ep_put_zcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        iov: *const uct_iov_t,
        iovcnt: usize,
        remote_addr: u64,
        rkey: uct_rkey_t,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_get_short_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        buffer: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_uint,
        remote_addr: u64,
        rkey: uct_rkey_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_get_bcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        unpack_cb: uct_unpack_callback_t,
        arg: *mut ::std::os::raw::c_void,
        length: usize,
        remote_addr: u64,
        rkey: uct_rkey_t,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_get_zcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        iov: *const uct_iov_t,
        iovcnt: usize,
        remote_addr: u64,
        rkey: uct_rkey_t,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_am_short_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        id: u8,
        header: u64,
        payload: *const ::std::os::raw::c_void,
        length: ::std::os::raw::c_uint,
    ) -> ucs_status_t,
>;
pub type uct_ep_am_short_iov_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        id: u8,
        iov: *const uct_iov_t,
        iovcnt: usize,
    ) -> ucs_status_t,
>;
pub type uct_ep_am_bcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        id: u8,
        pack_cb: uct_pack_callback_t,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> isize,
>;
pub type uct_ep_am_zcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        id: u8,
        header: *const ::std::os::raw::c_void,
        header_length: ::std::os::raw::c_uint,
        iov: *const uct_iov_t,
        iovcnt: usize,
        flags: ::std::os::raw::c_uint,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_atomic_cswap64_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        compare: u64,
        swap: u64,
        remote_addr: u64,
        rkey: uct_rkey_t,
        result: *mut u64,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_atomic_cswap32_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        compare: u32,
        swap: u32,
        remote_addr: u64,
        rkey: uct_rkey_t,
        result: *mut u32,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_atomic32_post_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        opcode: ::std::os::raw::c_uint,
        value: u32,
        remote_addr: u64,
        rkey: uct_rkey_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_atomic64_post_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        opcode: ::std::os::raw::c_uint,
        value: u64,
        remote_addr: u64,
        rkey: uct_rkey_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_atomic32_fetch_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        opcode: ::std::os::raw::c_uint,
        value: u32,
        result: *mut u32,
        remote_addr: u64,
        rkey: uct_rkey_t,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_atomic64_fetch_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        opcode: ::std::os::raw::c_uint,
        value: u64,
        result: *mut u64,
        remote_addr: u64,
        rkey: uct_rkey_t,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_tag_eager_short_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        tag: uct_tag_t,
        data: *const ::std::os::raw::c_void,
        length: usize,
    ) -> ucs_status_t,
>;
pub type uct_ep_tag_eager_bcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        tag: uct_tag_t,
        imm: u64,
        pack_cb: uct_pack_callback_t,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> isize,
>;
pub type uct_ep_tag_eager_zcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        tag: uct_tag_t,
        imm: u64,
        iov: *const uct_iov_t,
        iovcnt: usize,
        flags: ::std::os::raw::c_uint,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_tag_rndv_zcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        tag: uct_tag_t,
        header: *const ::std::os::raw::c_void,
        header_length: ::std::os::raw::c_uint,
        iov: *const uct_iov_t,
        iovcnt: usize,
        flags: ::std::os::raw::c_uint,
        comp: *mut uct_completion_t,
    ) -> ucs_status_ptr_t,
>;
pub type uct_ep_tag_rndv_cancel_func_t = ::std::option::Option<
    unsafe extern "C" fn(ep: uct_ep_h, op: *mut ::std::os::raw::c_void) -> ucs_status_t,
>;
pub type uct_ep_tag_rndv_request_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        tag: uct_tag_t,
        header: *const ::std::os::raw::c_void,
        header_length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ucs_status_t,
>;
pub type uct_iface_tag_recv_zcopy_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        iface: uct_iface_h,
        tag: uct_tag_t,
        tag_mask: uct_tag_t,
        iov: *const uct_iov_t,
        iovcnt: usize,
        ctx: *mut uct_tag_context_t,
    ) -> ucs_status_t,
>;
pub type uct_iface_tag_recv_cancel_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        iface: uct_iface_h,
        ctx: *mut uct_tag_context_t,
        force: ::std::os::raw::c_int,
    ) -> ucs_status_t,
>;
pub type uct_ep_pending_add_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        n: *mut uct_pending_req_t,
        flags: ::std::os::raw::c_uint,
    ) -> ucs_status_t,
>;
pub type uct_ep_pending_purge_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        cb: uct_pending_purge_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type uct_ep_flush_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        flags: ::std::os::raw::c_uint,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_fence_func_t = ::std::option::Option<
    unsafe extern "C" fn(ep: uct_ep_h, flags: ::std::os::raw::c_uint) -> ucs_status_t,
>;
pub type uct_ep_check_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        flags: ::std::os::raw::c_uint,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_ep_create_func_t = ::std::option::Option<
    unsafe extern "C" fn(params: *const uct_ep_params_t, ep_p: *mut uct_ep_h) -> ucs_status_t,
>;
pub type uct_ep_connect_func_t = ::std::option::Option<
    unsafe extern "C" fn(ep: uct_ep_h, params: *const uct_ep_connect_params_t) -> ucs_status_t,
>;
pub type uct_ep_disconnect_func_t = ::std::option::Option<
    unsafe extern "C" fn(ep: uct_ep_h, flags: ::std::os::raw::c_uint) -> ucs_status_t,
>;
pub type uct_cm_ep_conn_notify_func_t =
    ::std::option::Option<unsafe extern "C" fn(ep: uct_ep_h) -> ucs_status_t>;
pub type uct_ep_destroy_func_t = ::std::option::Option<unsafe extern "C" fn(ep: uct_ep_h)>;
pub type uct_ep_get_address_func_t = ::std::option::Option<
    unsafe extern "C" fn(ep: uct_ep_h, addr: *mut uct_ep_addr_t) -> ucs_status_t,
>;
pub type uct_ep_connect_to_ep_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ep: uct_ep_h,
        dev_addr: *const uct_device_addr_t,
        ep_addr: *const uct_ep_addr_t,
    ) -> ucs_status_t,
>;
pub type uct_iface_accept_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, conn_request: uct_conn_request_h) -> ucs_status_t,
>;
pub type uct_iface_reject_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, conn_request: uct_conn_request_h) -> ucs_status_t,
>;
pub type uct_iface_flush_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        iface: uct_iface_h,
        flags: ::std::os::raw::c_uint,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t,
>;
pub type uct_iface_fence_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, flags: ::std::os::raw::c_uint) -> ucs_status_t,
>;
pub type uct_iface_progress_enable_func_t =
    ::std::option::Option<unsafe extern "C" fn(iface: uct_iface_h, flags: ::std::os::raw::c_uint)>;
pub type uct_iface_progress_disable_func_t =
    ::std::option::Option<unsafe extern "C" fn(iface: uct_iface_h, flags: ::std::os::raw::c_uint)>;
pub type uct_iface_progress_func_t =
    ::std::option::Option<unsafe extern "C" fn(iface: uct_iface_h) -> ::std::os::raw::c_uint>;
pub type uct_iface_event_fd_get_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, fd_p: *mut ::std::os::raw::c_int) -> ucs_status_t,
>;
pub type uct_iface_event_arm_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, events: ::std::os::raw::c_uint) -> ucs_status_t,
>;
pub type uct_iface_close_func_t = ::std::option::Option<unsafe extern "C" fn(iface: uct_iface_h)>;
pub type uct_iface_query_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, iface_attr: *mut uct_iface_attr_t) -> ucs_status_t,
>;
pub type uct_iface_get_device_address_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, addr: *mut uct_device_addr_t) -> ucs_status_t,
>;
pub type uct_iface_get_address_func_t = ::std::option::Option<
    unsafe extern "C" fn(iface: uct_iface_h, addr: *mut uct_iface_addr_t) -> ucs_status_t,
>;
pub type uct_iface_is_reachable_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        iface: uct_iface_h,
        dev_addr: *const uct_device_addr_t,
        iface_addr: *const uct_iface_addr_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_ops {
    pub ep_put_short: uct_ep_put_short_func_t,
    pub ep_put_bcopy: uct_ep_put_bcopy_func_t,
    pub ep_put_zcopy: uct_ep_put_zcopy_func_t,
    pub ep_get_short: uct_ep_get_short_func_t,
    pub ep_get_bcopy: uct_ep_get_bcopy_func_t,
    pub ep_get_zcopy: uct_ep_get_zcopy_func_t,
    pub ep_am_short: uct_ep_am_short_func_t,
    pub ep_am_short_iov: uct_ep_am_short_iov_func_t,
    pub ep_am_bcopy: uct_ep_am_bcopy_func_t,
    pub ep_am_zcopy: uct_ep_am_zcopy_func_t,
    pub ep_atomic_cswap64: uct_ep_atomic_cswap64_func_t,
    pub ep_atomic_cswap32: uct_ep_atomic_cswap32_func_t,
    pub ep_atomic32_post: uct_ep_atomic32_post_func_t,
    pub ep_atomic64_post: uct_ep_atomic64_post_func_t,
    pub ep_atomic32_fetch: uct_ep_atomic32_fetch_func_t,
    pub ep_atomic64_fetch: uct_ep_atomic64_fetch_func_t,
    pub ep_tag_eager_short: uct_ep_tag_eager_short_func_t,
    pub ep_tag_eager_bcopy: uct_ep_tag_eager_bcopy_func_t,
    pub ep_tag_eager_zcopy: uct_ep_tag_eager_zcopy_func_t,
    pub ep_tag_rndv_zcopy: uct_ep_tag_rndv_zcopy_func_t,
    pub ep_tag_rndv_cancel: uct_ep_tag_rndv_cancel_func_t,
    pub ep_tag_rndv_request: uct_ep_tag_rndv_request_func_t,
    pub iface_tag_recv_zcopy: uct_iface_tag_recv_zcopy_func_t,
    pub iface_tag_recv_cancel: uct_iface_tag_recv_cancel_func_t,
    pub ep_pending_add: uct_ep_pending_add_func_t,
    pub ep_pending_purge: uct_ep_pending_purge_func_t,
    pub ep_flush: uct_ep_flush_func_t,
    pub ep_fence: uct_ep_fence_func_t,
    pub ep_check: uct_ep_check_func_t,
    pub ep_create: uct_ep_create_func_t,
    pub ep_connect: uct_ep_connect_func_t,
    pub ep_disconnect: uct_ep_disconnect_func_t,
    pub cm_ep_conn_notify: uct_cm_ep_conn_notify_func_t,
    pub ep_destroy: uct_ep_destroy_func_t,
    pub ep_get_address: uct_ep_get_address_func_t,
    pub ep_connect_to_ep: uct_ep_connect_to_ep_func_t,
    pub iface_accept: uct_iface_accept_func_t,
    pub iface_reject: uct_iface_reject_func_t,
    pub iface_flush: uct_iface_flush_func_t,
    pub iface_fence: uct_iface_fence_func_t,
    pub iface_progress_enable: uct_iface_progress_enable_func_t,
    pub iface_progress_disable: uct_iface_progress_disable_func_t,
    pub iface_progress: uct_iface_progress_func_t,
    pub iface_event_fd_get: uct_iface_event_fd_get_func_t,
    pub iface_event_arm: uct_iface_event_arm_func_t,
    pub iface_close: uct_iface_close_func_t,
    pub iface_query: uct_iface_query_func_t,
    pub iface_get_device_address: uct_iface_get_device_address_func_t,
    pub iface_get_address: uct_iface_get_address_func_t,
    pub iface_is_reachable: uct_iface_is_reachable_func_t,
}
#[test]
fn bindgen_test_layout_uct_iface_ops() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_ops> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_ops>(),
        400usize,
        concat!("Size of: ", stringify!(uct_iface_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_iface_ops))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_put_short) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_put_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_put_bcopy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_put_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_put_zcopy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_put_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_get_short) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_get_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_get_bcopy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_get_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_get_zcopy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_get_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_am_short) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_am_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_am_short_iov) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_am_short_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_am_bcopy) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_am_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_am_zcopy) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_am_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_atomic_cswap64) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_atomic_cswap64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_atomic_cswap32) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_atomic_cswap32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_atomic32_post) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_atomic32_post)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_atomic64_post) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_atomic64_post)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_atomic32_fetch) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_atomic32_fetch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_atomic64_fetch) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_atomic64_fetch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_tag_eager_short) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_tag_eager_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_tag_eager_bcopy) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_tag_eager_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_tag_eager_zcopy) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_tag_eager_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_tag_rndv_zcopy) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_tag_rndv_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_tag_rndv_cancel) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_tag_rndv_cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_tag_rndv_request) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_tag_rndv_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_tag_recv_zcopy) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_tag_recv_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_tag_recv_cancel) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_tag_recv_cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_pending_add) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_pending_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_pending_purge) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_pending_purge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_flush) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_fence) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_check) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_create) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_connect) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_disconnect) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_disconnect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cm_ep_conn_notify) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(cm_ep_conn_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_destroy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_get_address) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_get_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_connect_to_ep) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(ep_connect_to_ep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_accept) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_accept)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_reject) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_reject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_flush) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_fence) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_progress_enable) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_progress_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_progress_disable) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_progress_disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_progress) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_event_fd_get) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_event_fd_get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_event_arm) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_event_arm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_close) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_query) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_get_device_address) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_get_device_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_get_address) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_get_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_is_reachable) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_ops),
            "::",
            stringify!(iface_is_reachable)
        )
    );
}
pub type uct_iface_ops_t = uct_iface_ops;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_worker {
    pub progress_q: ucs_callbackq_t,
}
#[test]
fn bindgen_test_layout_uct_worker() {
    const UNINIT: ::std::mem::MaybeUninit<uct_worker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_worker>(),
        264usize,
        concat!("Size of: ", stringify!(uct_worker))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_worker>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_worker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_worker),
            "::",
            stringify!(progress_q)
        )
    );
}
pub type uct_worker_t = uct_worker;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface {
    pub ops: uct_iface_ops_t,
}
#[test]
fn bindgen_test_layout_uct_iface() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface>(),
        400usize,
        concat!("Size of: ", stringify!(uct_iface))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_iface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface),
            "::",
            stringify!(ops)
        )
    );
}
pub type uct_iface_t = uct_iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_ep {
    pub iface: uct_iface_h,
}
#[test]
fn bindgen_test_layout_uct_ep() {
    const UNINIT: ::std::mem::MaybeUninit<uct_ep> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_ep>(),
        8usize,
        concat!("Size of: ", stringify!(uct_ep))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_ep>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_ep))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep),
            "::",
            stringify!(iface)
        )
    );
}
pub type uct_ep_t = uct_ep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_listener {
    pub cm: uct_cm_h,
}
#[test]
fn bindgen_test_layout_uct_listener() {
    const UNINIT: ::std::mem::MaybeUninit<uct_listener> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_listener>(),
        8usize,
        concat!("Size of: ", stringify!(uct_listener))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_listener>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_listener))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_listener),
            "::",
            stringify!(cm)
        )
    );
}
pub type uct_listener_t = uct_listener;
pub type uct_recv_desc_t = uct_recv_desc;
pub type uct_desc_release_callback_t = ::std::option::Option<
    unsafe extern "C" fn(self_: *mut uct_recv_desc_t, desc: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_recv_desc {
    pub cb: uct_desc_release_callback_t,
}
#[test]
fn bindgen_test_layout_uct_recv_desc() {
    const UNINIT: ::std::mem::MaybeUninit<uct_recv_desc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_recv_desc>(),
        8usize,
        concat!("Size of: ", stringify!(uct_recv_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_recv_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_recv_desc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_recv_desc),
            "::",
            stringify!(cb)
        )
    );
}
pub type ucs_time_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_sys_event_set {
    _unused: [u8; 0],
}
pub type ucs_sys_event_set_t = ucs_sys_event_set;
pub type ucs_event_set_types_t = u8;
pub type ucs_event_set_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        events: ucs_event_set_types_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_event_set_type_t {
    UCS_EVENT_SET_EVREAD = 1,
    UCS_EVENT_SET_EVWRITE = 2,
    UCS_EVENT_SET_EVERR = 4,
    UCS_EVENT_SET_EDGE_TRIGGERED = 8,
}
extern "C" {
    pub static ucs_sys_event_set_max_wait_events: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ucs_event_set_create_from_fd(
        event_set_p: *mut *mut ucs_sys_event_set_t,
        event_fd: ::std::os::raw::c_int,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_event_set_create(event_set_p: *mut *mut ucs_sys_event_set_t) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_event_set_add(
        event_set: *mut ucs_sys_event_set_t,
        fd: ::std::os::raw::c_int,
        events: ucs_event_set_types_t,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_event_set_mod(
        event_set: *mut ucs_sys_event_set_t,
        fd: ::std::os::raw::c_int,
        events: ucs_event_set_types_t,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_event_set_del(
        event_set: *mut ucs_sys_event_set_t,
        fd: ::std::os::raw::c_int,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_event_set_wait(
        event_set: *mut ucs_sys_event_set_t,
        num_events: *mut ::std::os::raw::c_uint,
        timeout_ms: ::std::os::raw::c_int,
        event_set_handler: ucs_event_set_handler_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_event_set_cleanup(event_set: *mut ucs_sys_event_set_t);
}
extern "C" {
    pub fn ucs_event_set_fd_get(
        event_set: *mut ucs_sys_event_set_t,
        event_fd_p: *mut ::std::os::raw::c_int,
    ) -> ucs_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_async_context {
    _unused: [u8; 0],
}
pub type ucs_async_context_t = ucs_async_context;
pub type ucs_async_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: ::std::os::raw::c_int,
        events: ucs_event_set_types_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn ucs_async_set_event_handler(
        mode: ucs_async_mode_t,
        event_fd: ::std::os::raw::c_int,
        events: ucs_event_set_types_t,
        cb: ucs_async_event_cb_t,
        arg: *mut ::std::os::raw::c_void,
        async_: *mut ucs_async_context_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_async_add_timer(
        mode: ucs_async_mode_t,
        interval: ucs_time_t,
        cb: ucs_async_event_cb_t,
        arg: *mut ::std::os::raw::c_void,
        async_: *mut ucs_async_context_t,
        timer_id_p: *mut ::std::os::raw::c_int,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_async_remove_handler(
        id: ::std::os::raw::c_int,
        sync: ::std::os::raw::c_int,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_async_modify_handler(
        fd: ::std::os::raw::c_int,
        events: ucs_event_set_types_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_async_context_create(
        mode: ucs_async_mode_t,
        async_p: *mut *mut ucs_async_context_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_async_context_destroy(async_: *mut ucs_async_context_t);
}
extern "C" {
    pub fn ucs_async_poll(async_: *mut ucs_async_context_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_linear_func_t {
    pub c: f64,
    pub m: f64,
}
#[test]
fn bindgen_test_layout_ucs_linear_func_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_linear_func_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_linear_func_t>(),
        16usize,
        concat!("Size of: ", stringify!(ucs_linear_func_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_linear_func_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_linear_func_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_linear_func_t),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_linear_func_t),
            "::",
            stringify!(m)
        )
    );
}
impl ucs_memory_type {
    pub const UCS_MEMORY_TYPE_UNKNOWN: ucs_memory_type = ucs_memory_type::UCS_MEMORY_TYPE_LAST;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_memory_type {
    UCS_MEMORY_TYPE_HOST = 0,
    UCS_MEMORY_TYPE_CUDA = 1,
    UCS_MEMORY_TYPE_CUDA_MANAGED = 2,
    UCS_MEMORY_TYPE_ROCM = 3,
    UCS_MEMORY_TYPE_ROCM_MANAGED = 4,
    UCS_MEMORY_TYPE_LAST = 5,
}
pub use self::ucs_memory_type as ucs_memory_type_t;
extern "C" {
    pub static mut ucs_memory_type_names: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut ucs_memory_type_descs: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_thread_mode_t {
    UCS_THREAD_MODE_SINGLE = 0,
    UCS_THREAD_MODE_SERIALIZED = 1,
    UCS_THREAD_MODE_MULTI = 2,
    UCS_THREAD_MODE_LAST = 3,
}
extern "C" {
    pub static mut ucs_thread_mode_names: [*const ::std::os::raw::c_char; 0usize];
}
pub type ucs_cpu_mask_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_cpu_set_t {
    pub ucs_bits: [ucs_cpu_mask_t; 16usize],
}
#[test]
fn bindgen_test_layout_ucs_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(ucs_cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucs_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_cpu_set_t),
            "::",
            stringify!(ucs_bits)
        )
    );
}
pub type ucs_stats_counter_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_stats_class {
    _unused: [u8; 0],
}
pub type ucs_stats_class_t = ucs_stats_class;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_stats_node {
    _unused: [u8; 0],
}
pub type ucs_stats_node_t = ucs_stats_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_stats_filter_node {
    _unused: [u8; 0],
}
pub type ucs_stats_filter_node_t = ucs_stats_filter_node;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucs_stats_formats_t {
    UCS_STATS_FULL = 0,
    UCS_STATS_FULL_AGG = 1,
    UCS_STATS_SUMMARY = 2,
    UCS_STATS_LAST = 3,
}
extern "C" {
    pub static mut ucs_stats_formats_names: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn ucs_stats_get_root() -> *mut ucs_stats_node_t;
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_sys_bus_id {
    pub domain: u16,
    pub bus: u8,
    pub slot: u8,
    pub function: u8,
}
#[test]
fn bindgen_test_layout_ucs_sys_bus_id() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_sys_bus_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_sys_bus_id>(),
        6usize,
        concat!("Size of: ", stringify!(ucs_sys_bus_id))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_sys_bus_id>(),
        2usize,
        concat!("Alignment of ", stringify!(ucs_sys_bus_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_bus_id),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_bus_id),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_bus_id),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_bus_id),
            "::",
            stringify!(function)
        )
    );
}
pub type ucs_sys_bus_id_t = ucs_sys_bus_id;
pub type ucs_sys_device_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_sys_dev_distance {
    pub latency: f64,
    pub bandwidth: f64,
}
#[test]
fn bindgen_test_layout_ucs_sys_dev_distance() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_sys_dev_distance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_sys_dev_distance>(),
        16usize,
        concat!("Size of: ", stringify!(ucs_sys_dev_distance))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_sys_dev_distance>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_sys_dev_distance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_dev_distance),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_dev_distance),
            "::",
            stringify!(bandwidth)
        )
    );
}
pub type ucs_sys_dev_distance_t = ucs_sys_dev_distance;
extern "C" {
    pub static ucs_topo_default_distance: ucs_sys_dev_distance_t;
}
pub type ucs_topo_get_distance_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        device1: ucs_sys_device_t,
        device2: ucs_sys_device_t,
        distance: *mut ucs_sys_dev_distance_t,
    ) -> ucs_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucs_sys_topo_method_t {
    pub name: *const ::std::os::raw::c_char,
    pub get_distance: ucs_topo_get_distance_func_t,
    pub list: ucs_list_link_t,
}
#[test]
fn bindgen_test_layout_ucs_sys_topo_method_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucs_sys_topo_method_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucs_sys_topo_method_t>(),
        32usize,
        concat!("Size of: ", stringify!(ucs_sys_topo_method_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucs_sys_topo_method_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucs_sys_topo_method_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_topo_method_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_distance) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_topo_method_t),
            "::",
            stringify!(get_distance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucs_sys_topo_method_t),
            "::",
            stringify!(list)
        )
    );
}
extern "C" {
    pub static mut ucs_sys_topo_methods_list: ucs_list_link_t;
}
extern "C" {
    pub fn ucs_topo_find_device_by_bus_id(
        bus_id: *const ucs_sys_bus_id_t,
        sys_dev: *mut ucs_sys_device_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_topo_get_device_bus_id(
        sys_dev: ucs_sys_device_t,
        bus_id: *mut ucs_sys_bus_id_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_topo_get_distance(
        device1: ucs_sys_device_t,
        device2: ucs_sys_device_t,
        distance: *mut ucs_sys_dev_distance_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_topo_distance_str(
        distance: *const ucs_sys_dev_distance_t,
        buffer: *mut ::std::os::raw::c_char,
        max: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucs_topo_get_sysfs_dev(
        dev_name: *const ::std::os::raw::c_char,
        sysfs_path: *const ::std::os::raw::c_char,
        name_priority: ::std::os::raw::c_uint,
    ) -> ucs_sys_device_t;
}
extern "C" {
    pub fn ucs_topo_sys_device_bdf_name(
        sys_dev: ucs_sys_device_t,
        buffer: *mut ::std::os::raw::c_char,
        max: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucs_topo_find_device_by_bdf_name(
        name: *const ::std::os::raw::c_char,
        sys_dev: *mut ucs_sys_device_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_topo_sys_device_set_name(
        sys_dev: ucs_sys_device_t,
        name: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_uint,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucs_topo_get_pci_bw(
        dev_name: *const ::std::os::raw::c_char,
        sysfs_path: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn ucs_topo_sys_device_get_name(sys_dev: ucs_sys_device_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucs_topo_num_devices() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ucs_topo_print_info(stream: *mut FILE);
}
extern "C" {
    pub fn ucs_topo_init();
}
extern "C" {
    pub fn ucs_topo_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_md_resource_desc {
    pub md_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_uct_md_resource_desc() {
    const UNINIT: ::std::mem::MaybeUninit<uct_md_resource_desc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_md_resource_desc>(),
        16usize,
        concat!("Size of: ", stringify!(uct_md_resource_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_md_resource_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(uct_md_resource_desc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_resource_desc),
            "::",
            stringify!(md_name)
        )
    );
}
pub type uct_md_resource_desc_t = uct_md_resource_desc;
impl uct_component_attr_field {
    pub const UCT_COMPONENT_ATTR_FIELD_NAME: uct_component_attr_field = uct_component_attr_field(1);
}
impl uct_component_attr_field {
    pub const UCT_COMPONENT_ATTR_FIELD_MD_RESOURCE_COUNT: uct_component_attr_field =
        uct_component_attr_field(2);
}
impl uct_component_attr_field {
    pub const UCT_COMPONENT_ATTR_FIELD_MD_RESOURCES: uct_component_attr_field =
        uct_component_attr_field(4);
}
impl uct_component_attr_field {
    pub const UCT_COMPONENT_ATTR_FIELD_FLAGS: uct_component_attr_field =
        uct_component_attr_field(8);
}
impl ::std::ops::BitOr<uct_component_attr_field> for uct_component_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_component_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_component_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_component_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_component_attr_field> for uct_component_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_component_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_component_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_component_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_component_attr_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_component_attr {
    pub field_mask: u64,
    pub name: [::std::os::raw::c_char; 16usize],
    pub md_resource_count: ::std::os::raw::c_uint,
    pub md_resources: *mut uct_md_resource_desc_t,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_uct_component_attr() {
    const UNINIT: ::std::mem::MaybeUninit<uct_component_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_component_attr>(),
        48usize,
        concat!("Size of: ", stringify!(uct_component_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_component_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_component_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_component_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_component_attr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md_resource_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_component_attr),
            "::",
            stringify!(md_resource_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md_resources) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_component_attr),
            "::",
            stringify!(md_resources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_component_attr),
            "::",
            stringify!(flags)
        )
    );
}
pub type uct_component_attr_t = uct_component_attr;
pub const UCT_COMPONENT_FLAG_CM: _bindgen_ty_5 = _bindgen_ty_5::UCT_COMPONENT_FLAG_CM;
pub const UCT_COMPONENT_FLAG_RKEY_PTR: _bindgen_ty_5 = _bindgen_ty_5::UCT_COMPONENT_FLAG_RKEY_PTR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    UCT_COMPONENT_FLAG_CM = 1,
    UCT_COMPONENT_FLAG_RKEY_PTR = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_device_type_t {
    UCT_DEVICE_TYPE_NET = 0,
    UCT_DEVICE_TYPE_SHM = 1,
    UCT_DEVICE_TYPE_ACC = 2,
    UCT_DEVICE_TYPE_SELF = 3,
    UCT_DEVICE_TYPE_LAST = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_tl_resource_desc {
    pub tl_name: [::std::os::raw::c_char; 10usize],
    pub dev_name: [::std::os::raw::c_char; 32usize],
    pub dev_type: uct_device_type_t,
    pub sys_device: ucs_sys_device_t,
}
#[test]
fn bindgen_test_layout_uct_tl_resource_desc() {
    const UNINIT: ::std::mem::MaybeUninit<uct_tl_resource_desc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_tl_resource_desc>(),
        52usize,
        concat!("Size of: ", stringify!(uct_tl_resource_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_tl_resource_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(uct_tl_resource_desc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tl_resource_desc),
            "::",
            stringify!(tl_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_name) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tl_resource_desc),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_type) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tl_resource_desc),
            "::",
            stringify!(dev_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sys_device) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tl_resource_desc),
            "::",
            stringify!(sys_device)
        )
    );
}
pub type uct_tl_resource_desc_t = uct_tl_resource_desc;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_atomic_op {
    UCT_ATOMIC_OP_ADD = 0,
    UCT_ATOMIC_OP_AND = 1,
    UCT_ATOMIC_OP_OR = 2,
    UCT_ATOMIC_OP_XOR = 3,
    UCT_ATOMIC_OP_SWAP = 4,
    UCT_ATOMIC_OP_CSWAP = 5,
    UCT_ATOMIC_OP_LAST = 6,
}
pub use self::uct_atomic_op as uct_atomic_op_t;
impl uct_alloc_method_t {
    pub const UCT_ALLOC_METHOD_DEFAULT: uct_alloc_method_t =
        uct_alloc_method_t::UCT_ALLOC_METHOD_LAST;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_alloc_method_t {
    UCT_ALLOC_METHOD_THP = 0,
    UCT_ALLOC_METHOD_MD = 1,
    UCT_ALLOC_METHOD_HEAP = 2,
    UCT_ALLOC_METHOD_MMAP = 3,
    UCT_ALLOC_METHOD_HUGE = 4,
    UCT_ALLOC_METHOD_LAST = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_iface_event_types {
    UCT_EVENT_SEND_COMP = 1,
    UCT_EVENT_RECV = 2,
    UCT_EVENT_RECV_SIG = 4,
}
impl uct_flush_flags {
    pub const UCT_FLUSH_FLAG_LOCAL: uct_flush_flags = uct_flush_flags(0);
}
impl uct_flush_flags {
    pub const UCT_FLUSH_FLAG_CANCEL: uct_flush_flags = uct_flush_flags(1);
}
impl uct_flush_flags {
    pub const UCT_FLUSH_FLAG_REMOTE: uct_flush_flags = uct_flush_flags(2);
}
impl ::std::ops::BitOr<uct_flush_flags> for uct_flush_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_flush_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_flush_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_flush_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_flush_flags> for uct_flush_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_flush_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_flush_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_flush_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_flush_flags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_progress_types {
    UCT_PROGRESS_SEND = 1,
    UCT_PROGRESS_RECV = 2,
    UCT_PROGRESS_THREAD_SAFE = 128,
}
impl uct_msg_flags {
    pub const UCT_SEND_FLAG_SIGNALED: uct_msg_flags = uct_msg_flags(1);
}
impl uct_msg_flags {
    pub const UCT_SEND_FLAG_PEER_CHECK: uct_msg_flags = uct_msg_flags(2);
}
impl ::std::ops::BitOr<uct_msg_flags> for uct_msg_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_msg_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_msg_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_msg_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_msg_flags> for uct_msg_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_msg_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_msg_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_msg_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_msg_flags(pub ::std::os::raw::c_uint);
impl uct_cb_flags {
    pub const UCT_CB_FLAG_RESERVED: uct_cb_flags = uct_cb_flags(2);
}
impl uct_cb_flags {
    pub const UCT_CB_FLAG_ASYNC: uct_cb_flags = uct_cb_flags(4);
}
impl ::std::ops::BitOr<uct_cb_flags> for uct_cb_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cb_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cb_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cb_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cb_flags> for uct_cb_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cb_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cb_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cb_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cb_flags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_iface_open_mode {
    UCT_IFACE_OPEN_MODE_DEVICE = 1,
    UCT_IFACE_OPEN_MODE_SOCKADDR_SERVER = 2,
    UCT_IFACE_OPEN_MODE_SOCKADDR_CLIENT = 4,
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_CPU_MASK: uct_iface_params_field = uct_iface_params_field(1);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_OPEN_MODE: uct_iface_params_field = uct_iface_params_field(2);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_DEVICE: uct_iface_params_field = uct_iface_params_field(4);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_SOCKADDR: uct_iface_params_field = uct_iface_params_field(8);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_STATS_ROOT: uct_iface_params_field = uct_iface_params_field(16);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_RX_HEADROOM: uct_iface_params_field =
        uct_iface_params_field(32);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_ERR_HANDLER_ARG: uct_iface_params_field =
        uct_iface_params_field(64);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_ERR_HANDLER: uct_iface_params_field =
        uct_iface_params_field(128);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_ERR_HANDLER_FLAGS: uct_iface_params_field =
        uct_iface_params_field(256);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_HW_TM_EAGER_ARG: uct_iface_params_field =
        uct_iface_params_field(512);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_HW_TM_EAGER_CB: uct_iface_params_field =
        uct_iface_params_field(1024);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_HW_TM_RNDV_ARG: uct_iface_params_field =
        uct_iface_params_field(2048);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_HW_TM_RNDV_CB: uct_iface_params_field =
        uct_iface_params_field(4096);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_ASYNC_EVENT_ARG: uct_iface_params_field =
        uct_iface_params_field(8192);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_ASYNC_EVENT_CB: uct_iface_params_field =
        uct_iface_params_field(16384);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_KEEPALIVE_INTERVAL: uct_iface_params_field =
        uct_iface_params_field(32768);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_AM_ALIGNMENT: uct_iface_params_field =
        uct_iface_params_field(65536);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_AM_ALIGN_OFFSET: uct_iface_params_field =
        uct_iface_params_field(131072);
}
impl uct_iface_params_field {
    pub const UCT_IFACE_PARAM_FIELD_FEATURES: uct_iface_params_field =
        uct_iface_params_field(262144);
}
impl ::std::ops::BitOr<uct_iface_params_field> for uct_iface_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_iface_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_iface_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_iface_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_iface_params_field> for uct_iface_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_iface_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_iface_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_iface_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_iface_params_field(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_sockaddr_accessibility_t {
    UCT_SOCKADDR_ACC_LOCAL = 0,
    UCT_SOCKADDR_ACC_REMOTE = 1,
}
pub const UCT_MD_FLAG_ALLOC: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_ALLOC;
pub const UCT_MD_FLAG_REG: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_REG;
pub const UCT_MD_FLAG_NEED_MEMH: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_NEED_MEMH;
pub const UCT_MD_FLAG_NEED_RKEY: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_NEED_RKEY;
pub const UCT_MD_FLAG_ADVISE: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_ADVISE;
pub const UCT_MD_FLAG_FIXED: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_FIXED;
pub const UCT_MD_FLAG_RKEY_PTR: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_RKEY_PTR;
pub const UCT_MD_FLAG_SOCKADDR: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_SOCKADDR;
pub const UCT_MD_FLAG_INVALIDATE: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_INVALIDATE;
pub const UCT_MD_FLAG_EXPORTED_MKEY: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_EXPORTED_MKEY;
pub const UCT_MD_FLAG_REG_DMABUF: _bindgen_ty_6 = _bindgen_ty_6::UCT_MD_FLAG_REG_DMABUF;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    UCT_MD_FLAG_ALLOC = 1,
    UCT_MD_FLAG_REG = 2,
    UCT_MD_FLAG_NEED_MEMH = 4,
    UCT_MD_FLAG_NEED_RKEY = 8,
    UCT_MD_FLAG_ADVISE = 16,
    UCT_MD_FLAG_FIXED = 32,
    UCT_MD_FLAG_RKEY_PTR = 64,
    UCT_MD_FLAG_SOCKADDR = 128,
    UCT_MD_FLAG_INVALIDATE = 256,
    UCT_MD_FLAG_EXPORTED_MKEY = 512,
    UCT_MD_FLAG_REG_DMABUF = 1024,
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_FLAG_NONBLOCK: uct_md_mem_flags = uct_md_mem_flags(1);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_FLAG_FIXED: uct_md_mem_flags = uct_md_mem_flags(2);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_FLAG_LOCK: uct_md_mem_flags = uct_md_mem_flags(4);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_FLAG_HIDE_ERRORS: uct_md_mem_flags = uct_md_mem_flags(8);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_ACCESS_REMOTE_PUT: uct_md_mem_flags = uct_md_mem_flags(32);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_ACCESS_REMOTE_GET: uct_md_mem_flags = uct_md_mem_flags(64);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_ACCESS_REMOTE_ATOMIC: uct_md_mem_flags = uct_md_mem_flags(128);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_ACCESS_LOCAL_READ: uct_md_mem_flags = uct_md_mem_flags(256);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_ACCESS_LOCAL_WRITE: uct_md_mem_flags = uct_md_mem_flags(512);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_ACCESS_ALL: uct_md_mem_flags = uct_md_mem_flags(992);
}
impl uct_md_mem_flags {
    pub const UCT_MD_MEM_ACCESS_RMA: uct_md_mem_flags = uct_md_mem_flags(864);
}
impl ::std::ops::BitOr<uct_md_mem_flags> for uct_md_mem_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_md_mem_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_md_mem_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_md_mem_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_md_mem_flags> for uct_md_mem_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_md_mem_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_md_mem_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_md_mem_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_md_mem_flags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_mem_advice_t {
    UCT_MADV_NORMAL = 0,
    UCT_MADV_WILLNEED = 1,
}
impl uct_cm_attr_field {
    pub const UCT_CM_ATTR_FIELD_MAX_CONN_PRIV: uct_cm_attr_field = uct_cm_attr_field(1);
}
impl ::std::ops::BitOr<uct_cm_attr_field> for uct_cm_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_cm_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_cm_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_cm_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_cm_attr_field> for uct_cm_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_cm_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_cm_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_cm_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_cm_attr_field(pub ::std::os::raw::c_uint);
impl uct_listener_attr_field {
    pub const UCT_LISTENER_ATTR_FIELD_SOCKADDR: uct_listener_attr_field =
        uct_listener_attr_field(1);
}
impl ::std::ops::BitOr<uct_listener_attr_field> for uct_listener_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_listener_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_listener_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_listener_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_listener_attr_field> for uct_listener_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_listener_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_listener_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_listener_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_listener_attr_field(pub ::std::os::raw::c_uint);
impl uct_listener_params_field {
    pub const UCT_LISTENER_PARAM_FIELD_BACKLOG: uct_listener_params_field =
        uct_listener_params_field(1);
}
impl uct_listener_params_field {
    pub const UCT_LISTENER_PARAM_FIELD_CONN_REQUEST_CB: uct_listener_params_field =
        uct_listener_params_field(2);
}
impl uct_listener_params_field {
    pub const UCT_LISTENER_PARAM_FIELD_USER_DATA: uct_listener_params_field =
        uct_listener_params_field(4);
}
impl ::std::ops::BitOr<uct_listener_params_field> for uct_listener_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_listener_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_listener_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_listener_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_listener_params_field> for uct_listener_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_listener_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_listener_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_listener_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_listener_params_field(pub ::std::os::raw::c_uint);
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_IFACE: uct_ep_params_field = uct_ep_params_field(1);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_USER_DATA: uct_ep_params_field = uct_ep_params_field(2);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_DEV_ADDR: uct_ep_params_field = uct_ep_params_field(4);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_IFACE_ADDR: uct_ep_params_field = uct_ep_params_field(8);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_SOCKADDR: uct_ep_params_field = uct_ep_params_field(16);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_SOCKADDR_CB_FLAGS: uct_ep_params_field = uct_ep_params_field(32);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_SOCKADDR_PACK_CB: uct_ep_params_field = uct_ep_params_field(64);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_CM: uct_ep_params_field = uct_ep_params_field(128);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_CONN_REQUEST: uct_ep_params_field = uct_ep_params_field(256);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_SOCKADDR_CONNECT_CB_CLIENT: uct_ep_params_field =
        uct_ep_params_field(512);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_SOCKADDR_NOTIFY_CB_SERVER: uct_ep_params_field =
        uct_ep_params_field(1024);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_SOCKADDR_DISCONNECT_CB: uct_ep_params_field =
        uct_ep_params_field(2048);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_PATH_INDEX: uct_ep_params_field = uct_ep_params_field(4096);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_CM_RESOLVE_CB: uct_ep_params_field = uct_ep_params_field(8192);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_PRIV_DATA: uct_ep_params_field = uct_ep_params_field(16384);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_PRIV_DATA_LENGTH: uct_ep_params_field = uct_ep_params_field(32768);
}
impl uct_ep_params_field {
    pub const UCT_EP_PARAM_FIELD_LOCAL_SOCKADDR: uct_ep_params_field = uct_ep_params_field(65536);
}
impl ::std::ops::BitOr<uct_ep_params_field> for uct_ep_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_ep_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_ep_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_ep_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_ep_params_field> for uct_ep_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_ep_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_ep_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_ep_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_ep_params_field(pub ::std::os::raw::c_uint);
impl uct_ep_connect_params_field {
    pub const UCT_EP_CONNECT_PARAM_FIELD_PRIVATE_DATA: uct_ep_connect_params_field =
        uct_ep_connect_params_field(1);
}
impl uct_ep_connect_params_field {
    pub const UCT_EP_CONNECT_PARAM_FIELD_PRIVATE_DATA_LENGTH: uct_ep_connect_params_field =
        uct_ep_connect_params_field(2);
}
impl ::std::ops::BitOr<uct_ep_connect_params_field> for uct_ep_connect_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_ep_connect_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_ep_connect_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_ep_connect_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_ep_connect_params_field> for uct_ep_connect_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_ep_connect_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_ep_connect_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_ep_connect_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_ep_connect_params_field(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_iface_feature {
    UCT_IFACE_FEATURE_AM = 1,
    UCT_IFACE_FEATURE_PUT = 2,
    UCT_IFACE_FEATURE_GET = 4,
    UCT_IFACE_FEATURE_AMO32 = 8,
    UCT_IFACE_FEATURE_AMO64 = 16,
    UCT_IFACE_FEATURE_TAG = 32,
    UCT_IFACE_FEATURE_FLUSH_REMOTE = 64,
    UCT_IFACE_FEATURE_LAST = 128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_ppn_bandwidth {
    pub dedicated: f64,
    pub shared: f64,
}
#[test]
fn bindgen_test_layout_uct_ppn_bandwidth() {
    const UNINIT: ::std::mem::MaybeUninit<uct_ppn_bandwidth> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_ppn_bandwidth>(),
        16usize,
        concat!("Size of: ", stringify!(uct_ppn_bandwidth))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_ppn_bandwidth>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_ppn_bandwidth))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedicated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ppn_bandwidth),
            "::",
            stringify!(dedicated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ppn_bandwidth),
            "::",
            stringify!(shared)
        )
    );
}
pub type uct_ppn_bandwidth_t = uct_ppn_bandwidth;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr {
    pub cap: uct_iface_attr__bindgen_ty_1,
    pub device_addr_len: usize,
    pub iface_addr_len: usize,
    pub ep_addr_len: usize,
    pub max_conn_priv: usize,
    pub listen_sockaddr: sockaddr_storage,
    pub overhead: f64,
    pub bandwidth: uct_ppn_bandwidth_t,
    pub latency: ucs_linear_func_t,
    pub priority: u8,
    pub max_num_eps: usize,
    pub dev_num_paths: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1 {
    pub put: uct_iface_attr__bindgen_ty_1__bindgen_ty_1,
    pub get: uct_iface_attr__bindgen_ty_1__bindgen_ty_2,
    pub am: uct_iface_attr__bindgen_ty_1__bindgen_ty_3,
    pub tag: uct_iface_attr__bindgen_ty_1__bindgen_ty_4,
    pub atomic32: uct_iface_attr__bindgen_ty_1__bindgen_ty_5,
    pub atomic64: uct_iface_attr__bindgen_ty_1__bindgen_ty_5,
    pub flags: u64,
    pub event_flags: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_1 {
    pub max_short: usize,
    pub max_bcopy: usize,
    pub min_zcopy: usize,
    pub max_zcopy: usize,
    pub opt_zcopy_align: usize,
    pub align_mtu: usize,
    pub max_iov: usize,
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_attr__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_1>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_short) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(max_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bcopy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(max_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_zcopy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(min_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_zcopy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(max_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_zcopy_align) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(opt_zcopy_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).align_mtu) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(align_mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_iov) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(max_iov)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_2 {
    pub max_short: usize,
    pub max_bcopy: usize,
    pub min_zcopy: usize,
    pub max_zcopy: usize,
    pub opt_zcopy_align: usize,
    pub align_mtu: usize,
    pub max_iov: usize,
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_attr__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_2>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_short) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(max_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bcopy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(max_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_zcopy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(min_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_zcopy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(max_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_zcopy_align) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(opt_zcopy_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).align_mtu) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(align_mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_iov) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(max_iov)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_3 {
    pub max_short: usize,
    pub max_bcopy: usize,
    pub min_zcopy: usize,
    pub max_zcopy: usize,
    pub opt_zcopy_align: usize,
    pub align_mtu: usize,
    pub max_hdr: usize,
    pub max_iov: usize,
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_attr__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_3>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_short) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bcopy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_zcopy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(min_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_zcopy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_zcopy_align) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(opt_zcopy_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).align_mtu) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(align_mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_hdr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_iov) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max_iov)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_4 {
    pub recv: uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub eager: uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
    pub rndv: uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub min_recv: usize,
    pub max_zcopy: usize,
    pub max_iov: usize,
    pub max_outstanding: usize,
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_recv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(min_recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_zcopy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(max_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(max_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_outstanding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(max_outstanding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub max_short: usize,
    pub max_bcopy: usize,
    pub max_zcopy: usize,
    pub max_iov: usize,
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_short) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(max_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bcopy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(max_bcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_zcopy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(max_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_iov) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(max_iov)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3 {
    pub max_zcopy: usize,
    pub max_hdr: usize,
    pub max_iov: usize,
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_zcopy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3),
            "::",
            stringify!(max_zcopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_hdr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3),
            "::",
            stringify!(max_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4__bindgen_ty_3),
            "::",
            stringify!(max_iov)
        )
    );
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_attr__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eager) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(eager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rndv) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(rndv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_attr__bindgen_ty_1__bindgen_ty_5 {
    pub op_flags: u64,
    pub fop_flags: u64,
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_attr__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(op_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fop_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(fop_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_uct_iface_attr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_attr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr__bindgen_ty_1>(),
        312usize,
        concat!("Size of: ", stringify!(uct_iface_attr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_iface_attr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).put) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(am)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atomic32) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(atomic32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atomic64) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(atomic64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_flags) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr__bindgen_ty_1),
            "::",
            stringify!(event_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_uct_iface_attr() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_attr>(),
        536usize,
        concat!("Size of: ", stringify!(uct_iface_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_iface_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_addr_len) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(device_addr_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_addr_len) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(iface_addr_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep_addr_len) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(ep_addr_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_conn_priv) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(max_conn_priv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listen_sockaddr) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(listen_sockaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overhead) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(overhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bandwidth) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_num_eps) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(max_num_eps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_num_paths) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_attr),
            "::",
            stringify!(dev_num_paths)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uct_iface_params {
    pub field_mask: u64,
    pub cpu_mask: ucs_cpu_set_t,
    pub open_mode: u64,
    pub mode: uct_iface_params__bindgen_ty_1,
    pub stats_root: *mut ucs_stats_node_t,
    pub rx_headroom: usize,
    pub err_handler_arg: *mut ::std::os::raw::c_void,
    pub err_handler: uct_error_handler_t,
    pub err_handler_flags: u32,
    pub eager_arg: *mut ::std::os::raw::c_void,
    pub eager_cb: uct_tag_unexp_eager_cb_t,
    pub rndv_arg: *mut ::std::os::raw::c_void,
    pub rndv_cb: uct_tag_unexp_rndv_cb_t,
    pub async_event_arg: *mut ::std::os::raw::c_void,
    pub async_event_cb: uct_async_event_cb_t,
    pub keepalive_interval: ucs_time_t,
    pub am_alignment: usize,
    pub am_align_offset: usize,
    pub features: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uct_iface_params__bindgen_ty_1 {
    pub device: uct_iface_params__bindgen_ty_1__bindgen_ty_1,
    pub sockaddr: uct_iface_params__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_params__bindgen_ty_1__bindgen_ty_1 {
    pub tl_name: *const ::std::os::raw::c_char,
    pub dev_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uct_iface_params__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_params__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_params__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_params__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tl_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dev_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_iface_params__bindgen_ty_1__bindgen_ty_2 {
    pub listen_sockaddr: ucs_sock_addr_t,
    pub conn_request_arg: *mut ::std::os::raw::c_void,
    pub conn_request_cb: uct_sockaddr_conn_request_callback_t,
    pub cb_flags: u32,
}
#[test]
fn bindgen_test_layout_uct_iface_params__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_params__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_params__bindgen_ty_1__bindgen_ty_2>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_params__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listen_sockaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(listen_sockaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_request_arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(conn_request_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_request_cb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(conn_request_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(cb_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_uct_iface_params__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_params__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_params__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(uct_iface_params__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_params__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_iface_params__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params__bindgen_ty_1),
            "::",
            stringify!(sockaddr)
        )
    );
}
#[test]
fn bindgen_test_layout_uct_iface_params() {
    const UNINIT: ::std::mem::MaybeUninit<uct_iface_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_iface_params>(),
        304usize,
        concat!("Size of: ", stringify!(uct_iface_params))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_iface_params>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_iface_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(cpu_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_mode) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(open_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats_root) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(stats_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_headroom) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(rx_headroom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_handler_arg) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(err_handler_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_handler) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(err_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_handler_flags) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(err_handler_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eager_arg) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(eager_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eager_cb) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(eager_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rndv_arg) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(rndv_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rndv_cb) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(rndv_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_event_arg) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(async_event_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_event_cb) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(async_event_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepalive_interval) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(keepalive_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_alignment) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(am_alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_align_offset) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(am_align_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_iface_params),
            "::",
            stringify!(features)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_ep_params {
    pub field_mask: u64,
    pub iface: uct_iface_h,
    pub user_data: *mut ::std::os::raw::c_void,
    pub dev_addr: *const uct_device_addr_t,
    pub iface_addr: *const uct_iface_addr_t,
    pub sockaddr: *const ucs_sock_addr_t,
    pub sockaddr_cb_flags: u32,
    pub sockaddr_pack_cb: uct_cm_ep_priv_data_pack_callback_t,
    pub cm: uct_cm_h,
    pub conn_request: uct_conn_request_h,
    pub sockaddr_cb_client: uct_cm_ep_client_connect_callback_t,
    pub sockaddr_cb_server: uct_cm_ep_server_conn_notify_callback_t,
    pub disconnect_cb: uct_ep_disconnect_cb_t,
    pub path_index: ::std::os::raw::c_uint,
    pub cm_resolve_cb: uct_cm_ep_resolve_callback_t,
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_length: usize,
    pub local_sockaddr: *const ucs_sock_addr_t,
}
#[test]
fn bindgen_test_layout_uct_ep_params() {
    const UNINIT: ::std::mem::MaybeUninit<uct_ep_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_ep_params>(),
        144usize,
        concat!("Size of: ", stringify!(uct_ep_params))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_ep_params>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_ep_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(dev_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface_addr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(iface_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(sockaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr_cb_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(sockaddr_cb_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr_pack_cb) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(sockaddr_pack_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cm) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(cm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_request) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(conn_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr_cb_client) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(sockaddr_cb_client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr_cb_server) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(sockaddr_cb_server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect_cb) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(disconnect_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_index) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(path_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cm_resolve_cb) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(cm_resolve_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data_length) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(private_data_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sockaddr) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_params),
            "::",
            stringify!(local_sockaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_ep_connect_params {
    pub field_mask: u64,
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_length: usize,
}
#[test]
fn bindgen_test_layout_uct_ep_connect_params() {
    const UNINIT: ::std::mem::MaybeUninit<uct_ep_connect_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_ep_connect_params>(),
        24usize,
        concat!("Size of: ", stringify!(uct_ep_connect_params))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_ep_connect_params>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_ep_connect_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_connect_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_connect_params),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_ep_connect_params),
            "::",
            stringify!(private_data_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_cm_attr {
    pub field_mask: u64,
    pub max_conn_priv: usize,
}
#[test]
fn bindgen_test_layout_uct_cm_attr() {
    const UNINIT: ::std::mem::MaybeUninit<uct_cm_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_cm_attr>(),
        16usize,
        concat!("Size of: ", stringify!(uct_cm_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_cm_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_cm_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_conn_priv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_cm_attr),
            "::",
            stringify!(max_conn_priv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_listener_attr {
    pub field_mask: u64,
    pub sockaddr: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_uct_listener_attr() {
    const UNINIT: ::std::mem::MaybeUninit<uct_listener_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_listener_attr>(),
        136usize,
        concat!("Size of: ", stringify!(uct_listener_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_listener_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_listener_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_listener_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_listener_attr),
            "::",
            stringify!(sockaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_listener_params {
    pub field_mask: u64,
    pub backlog: ::std::os::raw::c_int,
    pub conn_request_cb: uct_cm_listener_conn_request_callback_t,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uct_listener_params() {
    const UNINIT: ::std::mem::MaybeUninit<uct_listener_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_listener_params>(),
        32usize,
        concat!("Size of: ", stringify!(uct_listener_params))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_listener_params>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_listener_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_listener_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backlog) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_listener_params),
            "::",
            stringify!(backlog)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_request_cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_listener_params),
            "::",
            stringify!(conn_request_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_listener_params),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_md_attr {
    pub cap: uct_md_attr__bindgen_ty_1,
    pub reg_cost: ucs_linear_func_t,
    pub component_name: [::std::os::raw::c_char; 16usize],
    pub rkey_packed_size: usize,
    pub local_cpus: ucs_cpu_set_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_md_attr__bindgen_ty_1 {
    pub max_alloc: u64,
    pub max_reg: usize,
    pub flags: u64,
    pub reg_mem_types: u64,
    pub detect_mem_types: u64,
    pub alloc_mem_types: u64,
    pub access_mem_types: u64,
}
#[test]
fn bindgen_test_layout_uct_md_attr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<uct_md_attr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_md_attr__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(uct_md_attr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_md_attr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_md_attr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr__bindgen_ty_1),
            "::",
            stringify!(max_alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_reg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr__bindgen_ty_1),
            "::",
            stringify!(max_reg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_mem_types) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr__bindgen_ty_1),
            "::",
            stringify!(reg_mem_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detect_mem_types) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr__bindgen_ty_1),
            "::",
            stringify!(detect_mem_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_mem_types) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr__bindgen_ty_1),
            "::",
            stringify!(alloc_mem_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_mem_types) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr__bindgen_ty_1),
            "::",
            stringify!(access_mem_types)
        )
    );
}
#[test]
fn bindgen_test_layout_uct_md_attr() {
    const UNINIT: ::std::mem::MaybeUninit<uct_md_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_md_attr>(),
        224usize,
        concat!("Size of: ", stringify!(uct_md_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_md_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_md_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_cost) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr),
            "::",
            stringify!(reg_cost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr),
            "::",
            stringify!(component_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rkey_packed_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr),
            "::",
            stringify!(rkey_packed_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_cpus) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_attr),
            "::",
            stringify!(local_cpus)
        )
    );
}
impl uct_md_mem_attr_field {
    pub const UCT_MD_MEM_ATTR_FIELD_MEM_TYPE: uct_md_mem_attr_field = uct_md_mem_attr_field(1);
}
impl uct_md_mem_attr_field {
    pub const UCT_MD_MEM_ATTR_FIELD_SYS_DEV: uct_md_mem_attr_field = uct_md_mem_attr_field(2);
}
impl uct_md_mem_attr_field {
    pub const UCT_MD_MEM_ATTR_FIELD_BASE_ADDRESS: uct_md_mem_attr_field = uct_md_mem_attr_field(4);
}
impl uct_md_mem_attr_field {
    pub const UCT_MD_MEM_ATTR_FIELD_ALLOC_LENGTH: uct_md_mem_attr_field = uct_md_mem_attr_field(8);
}
impl uct_md_mem_attr_field {
    pub const UCT_MD_MEM_ATTR_FIELD_DMABUF_FD: uct_md_mem_attr_field = uct_md_mem_attr_field(16);
}
impl uct_md_mem_attr_field {
    pub const UCT_MD_MEM_ATTR_FIELD_DMABUF_OFFSET: uct_md_mem_attr_field =
        uct_md_mem_attr_field(32);
}
impl ::std::ops::BitOr<uct_md_mem_attr_field> for uct_md_mem_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        uct_md_mem_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for uct_md_mem_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: uct_md_mem_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<uct_md_mem_attr_field> for uct_md_mem_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        uct_md_mem_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for uct_md_mem_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: uct_md_mem_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct uct_md_mem_attr_field(pub ::std::os::raw::c_uint);
pub use self::uct_md_mem_attr_field as uct_md_mem_attr_field_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_md_mem_attr {
    pub field_mask: u64,
    pub mem_type: ucs_memory_type_t,
    pub sys_dev: ucs_sys_device_t,
    pub base_address: *mut ::std::os::raw::c_void,
    pub alloc_length: usize,
    pub dmabuf_fd: ::std::os::raw::c_int,
    pub dmabuf_offset: usize,
}
#[test]
fn bindgen_test_layout_uct_md_mem_attr() {
    const UNINIT: ::std::mem::MaybeUninit<uct_md_mem_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_md_mem_attr>(),
        48usize,
        concat!("Size of: ", stringify!(uct_md_mem_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_md_mem_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_md_mem_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_mem_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_mem_attr),
            "::",
            stringify!(mem_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sys_dev) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_mem_attr),
            "::",
            stringify!(sys_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_mem_attr),
            "::",
            stringify!(base_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_mem_attr),
            "::",
            stringify!(alloc_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmabuf_fd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_mem_attr),
            "::",
            stringify!(dmabuf_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmabuf_offset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_md_mem_attr),
            "::",
            stringify!(dmabuf_offset)
        )
    );
}
pub type uct_md_mem_attr_t = uct_md_mem_attr;
extern "C" {
    pub fn uct_md_mem_query(
        md: uct_md_h,
        address: *const ::std::os::raw::c_void,
        length: usize,
        mem_attr: *mut uct_md_mem_attr_t,
    ) -> ucs_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_allocated_memory {
    pub address: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub method: uct_alloc_method_t,
    pub mem_type: ucs_memory_type_t,
    pub md: uct_md_h,
    pub memh: uct_mem_h,
}
#[test]
fn bindgen_test_layout_uct_allocated_memory() {
    const UNINIT: ::std::mem::MaybeUninit<uct_allocated_memory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_allocated_memory>(),
        40usize,
        concat!("Size of: ", stringify!(uct_allocated_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_allocated_memory>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_allocated_memory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_allocated_memory),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_allocated_memory),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_allocated_memory),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_allocated_memory),
            "::",
            stringify!(mem_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_allocated_memory),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memh) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_allocated_memory),
            "::",
            stringify!(memh)
        )
    );
}
pub type uct_allocated_memory_t = uct_allocated_memory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_rkey_bundle {
    pub rkey: uct_rkey_t,
    pub handle: *mut ::std::os::raw::c_void,
    pub type_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uct_rkey_bundle() {
    const UNINIT: ::std::mem::MaybeUninit<uct_rkey_bundle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_rkey_bundle>(),
        24usize,
        concat!("Size of: ", stringify!(uct_rkey_bundle))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_rkey_bundle>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_rkey_bundle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_rkey_bundle),
            "::",
            stringify!(rkey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_rkey_bundle),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_rkey_bundle),
            "::",
            stringify!(type_)
        )
    );
}
pub type uct_rkey_bundle_t = uct_rkey_bundle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_completion {
    pub func: uct_completion_callback_t,
    pub count: ::std::os::raw::c_int,
    pub status: ucs_status_t,
}
#[test]
fn bindgen_test_layout_uct_completion() {
    const UNINIT: ::std::mem::MaybeUninit<uct_completion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_completion>(),
        16usize,
        concat!("Size of: ", stringify!(uct_completion))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_completion>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_completion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_completion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_completion),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_completion),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_pending_req {
    pub func: uct_pending_callback_t,
    pub priv_: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_uct_pending_req() {
    const UNINIT: ::std::mem::MaybeUninit<uct_pending_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_pending_req>(),
        48usize,
        concat!("Size of: ", stringify!(uct_pending_req))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_pending_req>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_pending_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_pending_req),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_pending_req),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_tag_context {
    pub tag_consumed_cb: ::std::option::Option<unsafe extern "C" fn(self_: *mut uct_tag_context_t)>,
    pub completed_cb: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut uct_tag_context_t,
            stag: uct_tag_t,
            imm: u64,
            length: usize,
            inline_data: *mut ::std::os::raw::c_void,
            status: ucs_status_t,
        ),
    >,
    pub rndv_cb: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut uct_tag_context_t,
            stag: uct_tag_t,
            header: *const ::std::os::raw::c_void,
            header_length: ::std::os::raw::c_uint,
            status: ucs_status_t,
            flags: ::std::os::raw::c_uint,
        ),
    >,
    pub priv_: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_uct_tag_context() {
    const UNINIT: ::std::mem::MaybeUninit<uct_tag_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_tag_context>(),
        56usize,
        concat!("Size of: ", stringify!(uct_tag_context))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_tag_context>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_tag_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_consumed_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tag_context),
            "::",
            stringify!(tag_consumed_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).completed_cb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tag_context),
            "::",
            stringify!(completed_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rndv_cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tag_context),
            "::",
            stringify!(rndv_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_tag_context),
            "::",
            stringify!(priv_)
        )
    );
}
pub const UCT_TAG_RECV_CB_INLINE_DATA: _bindgen_ty_7 = _bindgen_ty_7::UCT_TAG_RECV_CB_INLINE_DATA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    UCT_TAG_RECV_CB_INLINE_DATA = 1,
}
extern "C" {
    pub static mut uct_alloc_method_names: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut uct_device_type_names: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn uct_query_components(
        components_p: *mut *mut uct_component_h,
        num_components_p: *mut ::std::os::raw::c_uint,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_release_component_list(components: *mut uct_component_h);
}
extern "C" {
    pub fn uct_component_query(
        component: uct_component_h,
        component_attr: *mut uct_component_attr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_open(
        component: uct_component_h,
        md_name: *const ::std::os::raw::c_char,
        config: *const uct_md_config_t,
        md_p: *mut uct_md_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_close(md: uct_md_h);
}
extern "C" {
    pub fn uct_md_query_tl_resources(
        md: uct_md_h,
        resources_p: *mut *mut uct_tl_resource_desc_t,
        num_resources_p: *mut ::std::os::raw::c_uint,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_release_tl_resource_list(resources: *mut uct_tl_resource_desc_t);
}
extern "C" {
    pub fn uct_worker_create(
        async_: *mut ucs_async_context_t,
        thread_mode: ucs_thread_mode_t,
        worker_p: *mut uct_worker_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_worker_destroy(worker: uct_worker_h);
}
extern "C" {
    pub fn uct_worker_progress_register_safe(
        worker: uct_worker_h,
        func: ucs_callback_t,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
        id_p: *mut uct_worker_cb_id_t,
    );
}
extern "C" {
    pub fn uct_worker_progress_unregister_safe(worker: uct_worker_h, id_p: *mut uct_worker_cb_id_t);
}
extern "C" {
    pub fn uct_md_iface_config_read(
        md: uct_md_h,
        tl_name: *const ::std::os::raw::c_char,
        env_prefix: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        config_p: *mut *mut uct_iface_config_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_config_release(config: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uct_config_get(
        config: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        max: usize,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_config_modify(
        config: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_open(
        md: uct_md_h,
        worker: uct_worker_h,
        params: *const uct_iface_params_t,
        config: *const uct_iface_config_t,
        iface_p: *mut uct_iface_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_close(iface: uct_iface_h);
}
extern "C" {
    pub fn uct_iface_query(iface: uct_iface_h, iface_attr: *mut uct_iface_attr_t) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_get_device_address(
        iface: uct_iface_h,
        addr: *mut uct_device_addr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_get_address(iface: uct_iface_h, addr: *mut uct_iface_addr_t) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_is_reachable(
        iface: uct_iface_h,
        dev_addr: *const uct_device_addr_t,
        iface_addr: *const uct_iface_addr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uct_ep_check(
        ep: uct_ep_h,
        flags: ::std::os::raw::c_uint,
        comp: *mut uct_completion_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_event_fd_get(
        iface: uct_iface_h,
        fd_p: *mut ::std::os::raw::c_int,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_event_arm(iface: uct_iface_h, events: ::std::os::raw::c_uint) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_mem_alloc(
        iface: uct_iface_h,
        length: usize,
        flags: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        mem: *mut uct_allocated_memory_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_mem_free(mem: *const uct_allocated_memory_t);
}
extern "C" {
    pub fn uct_iface_set_am_handler(
        iface: uct_iface_h,
        id: u8,
        cb: uct_am_callback_t,
        arg: *mut ::std::os::raw::c_void,
        flags: u32,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_set_am_tracer(
        iface: uct_iface_h,
        tracer: uct_am_tracer_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_accept(iface: uct_iface_h, conn_request: uct_conn_request_h) -> ucs_status_t;
}
extern "C" {
    pub fn uct_iface_reject(iface: uct_iface_h, conn_request: uct_conn_request_h) -> ucs_status_t;
}
extern "C" {
    pub fn uct_ep_create(params: *const uct_ep_params_t, ep_p: *mut uct_ep_h) -> ucs_status_t;
}
extern "C" {
    pub fn uct_ep_connect(ep: uct_ep_h, params: *const uct_ep_connect_params_t) -> ucs_status_t;
}
extern "C" {
    pub fn uct_ep_disconnect(ep: uct_ep_h, flags: ::std::os::raw::c_uint) -> ucs_status_t;
}
extern "C" {
    pub fn uct_ep_destroy(ep: uct_ep_h);
}
extern "C" {
    pub fn uct_ep_get_address(ep: uct_ep_h, addr: *mut uct_ep_addr_t) -> ucs_status_t;
}
extern "C" {
    pub fn uct_ep_connect_to_ep(
        ep: uct_ep_h,
        dev_addr: *const uct_device_addr_t,
        ep_addr: *const uct_ep_addr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_query(md: uct_md_h, md_attr: *mut uct_md_attr_t) -> ucs_status_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum uct_mem_alloc_params_field_t {
    UCT_MEM_ALLOC_PARAM_FIELD_FLAGS = 1,
    UCT_MEM_ALLOC_PARAM_FIELD_ADDRESS = 2,
    UCT_MEM_ALLOC_PARAM_FIELD_MEM_TYPE = 4,
    UCT_MEM_ALLOC_PARAM_FIELD_MDS = 8,
    UCT_MEM_ALLOC_PARAM_FIELD_NAME = 16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_mem_alloc_params_t {
    pub field_mask: u64,
    pub flags: ::std::os::raw::c_uint,
    pub address: *mut ::std::os::raw::c_void,
    pub mem_type: ucs_memory_type_t,
    pub mds: uct_mem_alloc_params_t__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uct_mem_alloc_params_t__bindgen_ty_1 {
    pub mds: *const uct_md_h,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uct_mem_alloc_params_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<uct_mem_alloc_params_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_mem_alloc_params_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(uct_mem_alloc_params_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uct_mem_alloc_params_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uct_mem_alloc_params_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t__bindgen_ty_1),
            "::",
            stringify!(mds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
#[test]
fn bindgen_test_layout_uct_mem_alloc_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<uct_mem_alloc_params_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uct_mem_alloc_params_t>(),
        56usize,
        concat!("Size of: ", stringify!(uct_mem_alloc_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uct_mem_alloc_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uct_mem_alloc_params_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t),
            "::",
            stringify!(mem_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mds) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t),
            "::",
            stringify!(mds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uct_mem_alloc_params_t),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    pub fn uct_md_mem_advise(
        md: uct_md_h,
        memh: uct_mem_h,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        advice: uct_mem_advice_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_mem_reg(
        md: uct_md_h,
        address: *mut ::std::os::raw::c_void,
        length: usize,
        flags: ::std::os::raw::c_uint,
        memh_p: *mut uct_mem_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_mem_dereg(md: uct_md_h, memh: uct_mem_h) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_detect_memory_type(
        md: uct_md_h,
        addr: *const ::std::os::raw::c_void,
        length: usize,
        mem_type_p: *mut ucs_memory_type_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_mem_alloc(
        length: usize,
        methods: *const uct_alloc_method_t,
        num_methods: ::std::os::raw::c_uint,
        params: *const uct_mem_alloc_params_t,
        mem: *mut uct_allocated_memory_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_mem_free(mem: *const uct_allocated_memory_t) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_config_read(
        component: uct_component_h,
        env_prefix: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        config_p: *mut *mut uct_md_config_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_md_is_sockaddr_accessible(
        md: uct_md_h,
        sockaddr: *const ucs_sock_addr_t,
        mode: uct_sockaddr_accessibility_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uct_md_mkey_pack(
        md: uct_md_h,
        memh: uct_mem_h,
        rkey_buffer: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_rkey_unpack(
        component: uct_component_h,
        rkey_buffer: *const ::std::os::raw::c_void,
        rkey_ob: *mut uct_rkey_bundle_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_rkey_ptr(
        component: uct_component_h,
        rkey_ob: *mut uct_rkey_bundle_t,
        remote_addr: u64,
        addr_p: *mut *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_rkey_release(
        component: uct_component_h,
        rkey_ob: *const uct_rkey_bundle_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_cm_open(
        component: uct_component_h,
        worker: uct_worker_h,
        config: *const uct_cm_config_t,
        cm_p: *mut uct_cm_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_cm_close(cm: uct_cm_h);
}
extern "C" {
    pub fn uct_cm_query(cm: uct_cm_h, cm_attr: *mut uct_cm_attr_t) -> ucs_status_t;
}
extern "C" {
    pub fn uct_cm_config_read(
        component: uct_component_h,
        env_prefix: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        config_p: *mut *mut uct_cm_config_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_cm_client_ep_conn_notify(ep: uct_ep_h) -> ucs_status_t;
}
extern "C" {
    pub fn uct_listener_create(
        cm: uct_cm_h,
        saddr: *const sockaddr,
        socklen: socklen_t,
        params: *const uct_listener_params_t,
        listener_p: *mut uct_listener_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_listener_destroy(listener: uct_listener_h);
}
extern "C" {
    pub fn uct_listener_reject(
        listener: uct_listener_h,
        conn_request: uct_conn_request_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn uct_listener_query(
        listener: uct_listener_h,
        listener_attr: *mut uct_listener_attr_t,
    ) -> ucs_status_t;
}
pub type ucp_tag_recv_info_t = ucp_tag_recv_info;
pub type ucp_am_recv_param_t = ucp_am_recv_param;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_context {
    _unused: [u8; 0],
}
pub type ucp_context_h = *mut ucp_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_config {
    _unused: [u8; 0],
}
pub type ucp_config_t = ucp_config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_ep {
    _unused: [u8; 0],
}
pub type ucp_ep_h = *mut ucp_ep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_conn_request {
    _unused: [u8; 0],
}
pub type ucp_conn_request_h = *mut ucp_conn_request;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_address {
    _unused: [u8; 0],
}
pub type ucp_address_t = ucp_address;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_err_handling_mode_t {
    UCP_ERR_HANDLING_MODE_NONE = 0,
    UCP_ERR_HANDLING_MODE_PEER = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_rkey {
    _unused: [u8; 0],
}
pub type ucp_rkey_h = *mut ucp_rkey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_mem {
    _unused: [u8; 0],
}
pub type ucp_mem_h = *mut ucp_mem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_listener {
    _unused: [u8; 0],
}
pub type ucp_listener_h = *mut ucp_listener;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_mem_attr {
    pub field_mask: u64,
    pub address: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub mem_type: ucs_memory_type_t,
}
#[test]
fn bindgen_test_layout_ucp_mem_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_mem_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_mem_attr>(),
        32usize,
        concat!("Size of: ", stringify!(ucp_mem_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_mem_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_mem_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_attr),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_attr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_attr),
            "::",
            stringify!(mem_type)
        )
    );
}
pub type ucp_mem_attr_t = ucp_mem_attr;
impl ucp_mem_attr_field {
    pub const UCP_MEM_ATTR_FIELD_ADDRESS: ucp_mem_attr_field = ucp_mem_attr_field(1);
}
impl ucp_mem_attr_field {
    pub const UCP_MEM_ATTR_FIELD_LENGTH: ucp_mem_attr_field = ucp_mem_attr_field(2);
}
impl ucp_mem_attr_field {
    pub const UCP_MEM_ATTR_FIELD_MEM_TYPE: ucp_mem_attr_field = ucp_mem_attr_field(4);
}
impl ::std::ops::BitOr<ucp_mem_attr_field> for ucp_mem_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_mem_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_mem_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_mem_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_mem_attr_field> for ucp_mem_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_mem_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_mem_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_mem_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_mem_attr_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_worker {
    _unused: [u8; 0],
}
pub type ucp_worker_h = *mut ucp_worker;
pub type ucp_tag_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_recv_desc {
    _unused: [u8; 0],
}
pub type ucp_tag_message_h = *mut ucp_recv_desc;
pub type ucp_datatype_t = u64;
pub type ucp_request_init_callback_t =
    ::std::option::Option<unsafe extern "C" fn(request: *mut ::std::os::raw::c_void)>;
pub type ucp_request_cleanup_callback_t =
    ::std::option::Option<unsafe extern "C" fn(request: *mut ::std::os::raw::c_void)>;
pub type ucp_send_callback_t = ::std::option::Option<
    unsafe extern "C" fn(request: *mut ::std::os::raw::c_void, status: ucs_status_t),
>;
pub type ucp_send_nbx_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *mut ::std::os::raw::c_void,
        status: ucs_status_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ucp_err_handler_cb_t = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, ep: ucp_ep_h, status: ucs_status_t),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_err_handler {
    pub cb: ucp_err_handler_cb_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucp_err_handler() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_err_handler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_err_handler>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_err_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_err_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_err_handler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_err_handler),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_err_handler),
            "::",
            stringify!(arg)
        )
    );
}
pub type ucp_err_handler_t = ucp_err_handler;
pub type ucp_listener_accept_callback_t =
    ::std::option::Option<unsafe extern "C" fn(ep: ucp_ep_h, arg: *mut ::std::os::raw::c_void)>;
pub type ucp_listener_conn_callback_t = ::std::option::Option<
    unsafe extern "C" fn(conn_request: ucp_conn_request_h, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_listener_conn_handler {
    pub cb: ucp_listener_conn_callback_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucp_listener_conn_handler() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_listener_conn_handler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_listener_conn_handler>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_listener_conn_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_listener_conn_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_listener_conn_handler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_conn_handler),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_conn_handler),
            "::",
            stringify!(arg)
        )
    );
}
pub type ucp_listener_conn_handler_t = ucp_listener_conn_handler;
pub type ucp_stream_recv_callback_t = ::std::option::Option<
    unsafe extern "C" fn(request: *mut ::std::os::raw::c_void, status: ucs_status_t, length: usize),
>;
pub type ucp_stream_recv_nbx_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *mut ::std::os::raw::c_void,
        status: ucs_status_t,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ucp_tag_recv_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *mut ::std::os::raw::c_void,
        status: ucs_status_t,
        info: *mut ucp_tag_recv_info_t,
    ),
>;
pub type ucp_tag_recv_nbx_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *mut ::std::os::raw::c_void,
        status: ucs_status_t,
        tag_info: *const ucp_tag_recv_info_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ucp_am_recv_data_nbx_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *mut ::std::os::raw::c_void,
        status: ucs_status_t,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_wakeup_event_types {
    UCP_WAKEUP_RMA = 1,
    UCP_WAKEUP_AMO = 2,
    UCP_WAKEUP_TAG_SEND = 4,
    UCP_WAKEUP_TAG_RECV = 8,
    UCP_WAKEUP_TX = 1024,
    UCP_WAKEUP_RX = 2048,
    UCP_WAKEUP_EDGE = 65536,
}
pub use self::ucp_wakeup_event_types as ucp_wakeup_event_t;
pub type ucp_am_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        length: usize,
        reply_ep: ucp_ep_h,
        flags: ::std::os::raw::c_uint,
    ) -> ucs_status_t,
>;
pub type ucp_am_recv_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        header: *const ::std::os::raw::c_void,
        header_length: usize,
        data: *mut ::std::os::raw::c_void,
        length: usize,
        param: *const ucp_am_recv_param_t,
    ) -> ucs_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_ep_params {
    pub field_mask: u64,
    pub address: *const ucp_address_t,
    pub err_mode: ucp_err_handling_mode_t,
    pub err_handler: ucp_err_handler_t,
    pub user_data: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
    pub sockaddr: ucs_sock_addr_t,
    pub conn_request: ucp_conn_request_h,
    pub name: *const ::std::os::raw::c_char,
    pub local_sockaddr: ucs_sock_addr_t,
}
#[test]
fn bindgen_test_layout_ucp_ep_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_ep_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_ep_params>(),
        104usize,
        concat!("Size of: ", stringify!(ucp_ep_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_ep_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_ep_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(err_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_handler) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(err_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(sockaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_request) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(conn_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sockaddr) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_params),
            "::",
            stringify!(local_sockaddr)
        )
    );
}
pub type ucp_ep_params_t = ucp_ep_params;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_transport_entry_t {
    pub transport_name: *const ::std::os::raw::c_char,
    pub device_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ucp_transport_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_transport_entry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_transport_entry_t>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_transport_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_transport_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_transport_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_transport_entry_t),
            "::",
            stringify!(transport_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_transport_entry_t),
            "::",
            stringify!(device_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_transports_t {
    pub entries: *mut ucp_transport_entry_t,
    pub num_entries: ::std::os::raw::c_uint,
    pub entry_size: usize,
}
#[test]
fn bindgen_test_layout_ucp_transports_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_transports_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_transports_t>(),
        24usize,
        concat!("Size of: ", stringify!(ucp_transports_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_transports_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_transports_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_transports_t),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_entries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_transports_t),
            "::",
            stringify!(num_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_transports_t),
            "::",
            stringify!(entry_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_listener_accept_handler {
    pub cb: ucp_listener_accept_callback_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucp_listener_accept_handler() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_listener_accept_handler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_listener_accept_handler>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_listener_accept_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_listener_accept_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_listener_accept_handler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_accept_handler),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_accept_handler),
            "::",
            stringify!(arg)
        )
    );
}
pub type ucp_listener_accept_handler_t = ucp_listener_accept_handler;
extern "C" {
    pub fn ucp_request_is_completed(request: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucp_request_release(request: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ucp_ep_destroy(ep: ucp_ep_h);
}
extern "C" {
    pub fn ucp_disconnect_nb(ep: ucp_ep_h) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_request_test(
        request: *mut ::std::os::raw::c_void,
        info: *mut ucp_tag_recv_info_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_rkey_pack(
        context: ucp_context_h,
        memh: ucp_mem_h,
        rkey_buffer_p: *mut *mut ::std::os::raw::c_void,
        size_p: *mut usize,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_rkey_buffer_release(rkey_buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ucp_ep_flush(ep: ucp_ep_h) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_flush(worker: ucp_worker_h) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_put(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_get(
        ep: ucp_ep_h,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_add32(
        ep: ucp_ep_h,
        add: u32,
        remote_addr: u64,
        rkey: ucp_rkey_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_add64(
        ep: ucp_ep_h,
        add: u64,
        remote_addr: u64,
        rkey: ucp_rkey_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_fadd32(
        ep: ucp_ep_h,
        add: u32,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        result: *mut u32,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_fadd64(
        ep: ucp_ep_h,
        add: u64,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        result: *mut u64,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_swap32(
        ep: ucp_ep_h,
        swap: u32,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        result: *mut u32,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_swap64(
        ep: ucp_ep_h,
        swap: u64,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        result: *mut u64,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_cswap32(
        ep: ucp_ep_h,
        compare: u32,
        swap: u32,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        result: *mut u32,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_atomic_cswap64(
        ep: ucp_ep_h,
        compare: u64,
        swap: u64,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        result: *mut u64,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_ep_modify_nb(ep: ucp_ep_h, params: *const ucp_ep_params_t) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_worker_get_address(
        worker: ucp_worker_h,
        address_p: *mut *mut ucp_address_t,
        address_length_p: *mut usize,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_ep_close_nb(ep: ucp_ep_h, mode: ::std::os::raw::c_uint) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_ep_flush_nb(
        ep: ucp_ep_h,
        flags: ::std::os::raw::c_uint,
        cb: ucp_send_callback_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_worker_set_am_handler(
        worker: ucp_worker_h,
        id: u16,
        cb: ucp_am_callback_t,
        arg: *mut ::std::os::raw::c_void,
        flags: u32,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_am_send_nb(
        ep: ucp_ep_h,
        id: u16,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        cb: ucp_send_callback_t,
        flags: ::std::os::raw::c_uint,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_stream_send_nb(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        cb: ucp_send_callback_t,
        flags: ::std::os::raw::c_uint,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_stream_recv_nb(
        ep: ucp_ep_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        cb: ucp_stream_recv_callback_t,
        length: *mut usize,
        flags: ::std::os::raw::c_uint,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_send_nb(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        tag: ucp_tag_t,
        cb: ucp_send_callback_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_send_nbr(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        tag: ucp_tag_t,
        req: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_tag_send_sync_nb(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        tag: ucp_tag_t,
        cb: ucp_send_callback_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_recv_nb(
        worker: ucp_worker_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        tag: ucp_tag_t,
        tag_mask: ucp_tag_t,
        cb: ucp_tag_recv_callback_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_recv_nbr(
        worker: ucp_worker_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        tag: ucp_tag_t,
        tag_mask: ucp_tag_t,
        req: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_tag_msg_recv_nb(
        worker: ucp_worker_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        datatype: ucp_datatype_t,
        message: ucp_tag_message_h,
        cb: ucp_tag_recv_callback_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_put_nbi(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_put_nb(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        cb: ucp_send_callback_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_get_nbi(
        ep: ucp_ep_h,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_get_nb(
        ep: ucp_ep_h,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        cb: ucp_send_callback_t,
    ) -> ucs_status_ptr_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_atomic_post_op_t {
    UCP_ATOMIC_POST_OP_ADD = 0,
    UCP_ATOMIC_POST_OP_AND = 1,
    UCP_ATOMIC_POST_OP_OR = 2,
    UCP_ATOMIC_POST_OP_XOR = 3,
    UCP_ATOMIC_POST_OP_LAST = 4,
}
extern "C" {
    pub fn ucp_atomic_post(
        ep: ucp_ep_h,
        opcode: ucp_atomic_post_op_t,
        value: u64,
        op_size: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
    ) -> ucs_status_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_atomic_fetch_op_t {
    UCP_ATOMIC_FETCH_OP_FADD = 0,
    UCP_ATOMIC_FETCH_OP_SWAP = 1,
    UCP_ATOMIC_FETCH_OP_CSWAP = 2,
    UCP_ATOMIC_FETCH_OP_FAND = 3,
    UCP_ATOMIC_FETCH_OP_FOR = 4,
    UCP_ATOMIC_FETCH_OP_FXOR = 5,
    UCP_ATOMIC_FETCH_OP_LAST = 6,
}
extern "C" {
    pub fn ucp_atomic_fetch_nb(
        ep: ucp_ep_h,
        opcode: ucp_atomic_fetch_op_t,
        value: u64,
        result: *mut ::std::os::raw::c_void,
        op_size: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        cb: ucp_send_callback_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_worker_flush_nb(
        worker: ucp_worker_h,
        flags: ::std::os::raw::c_uint,
        cb: ucp_send_callback_t,
    ) -> ucs_status_ptr_t;
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_FEATURES: ucp_params_field = ucp_params_field(1);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_REQUEST_SIZE: ucp_params_field = ucp_params_field(2);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_REQUEST_INIT: ucp_params_field = ucp_params_field(4);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_REQUEST_CLEANUP: ucp_params_field = ucp_params_field(8);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_TAG_SENDER_MASK: ucp_params_field = ucp_params_field(16);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_MT_WORKERS_SHARED: ucp_params_field = ucp_params_field(32);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_ESTIMATED_NUM_EPS: ucp_params_field = ucp_params_field(64);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_ESTIMATED_NUM_PPN: ucp_params_field = ucp_params_field(128);
}
impl ucp_params_field {
    pub const UCP_PARAM_FIELD_NAME: ucp_params_field = ucp_params_field(256);
}
impl ::std::ops::BitOr<ucp_params_field> for ucp_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_params_field> for ucp_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_params_field(pub ::std::os::raw::c_uint);
impl ucp_feature {
    pub const UCP_FEATURE_TAG: ucp_feature = ucp_feature(1);
}
impl ucp_feature {
    pub const UCP_FEATURE_RMA: ucp_feature = ucp_feature(2);
}
impl ucp_feature {
    pub const UCP_FEATURE_AMO32: ucp_feature = ucp_feature(4);
}
impl ucp_feature {
    pub const UCP_FEATURE_AMO64: ucp_feature = ucp_feature(8);
}
impl ucp_feature {
    pub const UCP_FEATURE_WAKEUP: ucp_feature = ucp_feature(16);
}
impl ucp_feature {
    pub const UCP_FEATURE_STREAM: ucp_feature = ucp_feature(32);
}
impl ucp_feature {
    pub const UCP_FEATURE_AM: ucp_feature = ucp_feature(64);
}
impl ucp_feature {
    pub const UCP_FEATURE_EXPORTED_MEMH: ucp_feature = ucp_feature(128);
}
impl ::std::ops::BitOr<ucp_feature> for ucp_feature {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_feature(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_feature {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_feature) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_feature> for ucp_feature {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_feature(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_feature {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_feature) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_feature(pub ::std::os::raw::c_uint);
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_THREAD_MODE: ucp_worker_params_field =
        ucp_worker_params_field(1);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_CPU_MASK: ucp_worker_params_field = ucp_worker_params_field(2);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_EVENTS: ucp_worker_params_field = ucp_worker_params_field(4);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_USER_DATA: ucp_worker_params_field =
        ucp_worker_params_field(8);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_EVENT_FD: ucp_worker_params_field =
        ucp_worker_params_field(16);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_FLAGS: ucp_worker_params_field = ucp_worker_params_field(32);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_NAME: ucp_worker_params_field = ucp_worker_params_field(64);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_AM_ALIGNMENT: ucp_worker_params_field =
        ucp_worker_params_field(128);
}
impl ucp_worker_params_field {
    pub const UCP_WORKER_PARAM_FIELD_CLIENT_ID: ucp_worker_params_field =
        ucp_worker_params_field(256);
}
impl ::std::ops::BitOr<ucp_worker_params_field> for ucp_worker_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_worker_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_worker_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_worker_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_worker_params_field> for ucp_worker_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_worker_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_worker_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_worker_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_worker_params_field(pub ::std::os::raw::c_uint);
impl ucp_worker_flags_t {
    pub const UCP_WORKER_FLAG_IGNORE_REQUEST_LEAK: ucp_worker_flags_t = ucp_worker_flags_t(1);
}
impl ::std::ops::BitOr<ucp_worker_flags_t> for ucp_worker_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_worker_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_worker_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_worker_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_worker_flags_t> for ucp_worker_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_worker_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_worker_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_worker_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_worker_flags_t(pub ::std::os::raw::c_uint);
impl ucp_listener_params_field {
    pub const UCP_LISTENER_PARAM_FIELD_SOCK_ADDR: ucp_listener_params_field =
        ucp_listener_params_field(1);
}
impl ucp_listener_params_field {
    pub const UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER: ucp_listener_params_field =
        ucp_listener_params_field(2);
}
impl ucp_listener_params_field {
    pub const UCP_LISTENER_PARAM_FIELD_CONN_HANDLER: ucp_listener_params_field =
        ucp_listener_params_field(4);
}
impl ::std::ops::BitOr<ucp_listener_params_field> for ucp_listener_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_listener_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_listener_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_listener_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_listener_params_field> for ucp_listener_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_listener_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_listener_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_listener_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_listener_params_field(pub ::std::os::raw::c_uint);
impl ucp_worker_address_flags_t {
    pub const UCP_WORKER_ADDRESS_FLAG_NET_ONLY: ucp_worker_address_flags_t =
        ucp_worker_address_flags_t(1);
}
impl ::std::ops::BitOr<ucp_worker_address_flags_t> for ucp_worker_address_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_worker_address_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_worker_address_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_worker_address_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_worker_address_flags_t> for ucp_worker_address_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_worker_address_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_worker_address_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_worker_address_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_worker_address_flags_t(pub ::std::os::raw::c_uint);
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_REMOTE_ADDRESS: ucp_ep_params_field = ucp_ep_params_field(1);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_ERR_HANDLING_MODE: ucp_ep_params_field = ucp_ep_params_field(2);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_ERR_HANDLER: ucp_ep_params_field = ucp_ep_params_field(4);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_USER_DATA: ucp_ep_params_field = ucp_ep_params_field(8);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_SOCK_ADDR: ucp_ep_params_field = ucp_ep_params_field(16);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_FLAGS: ucp_ep_params_field = ucp_ep_params_field(32);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_CONN_REQUEST: ucp_ep_params_field = ucp_ep_params_field(64);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_NAME: ucp_ep_params_field = ucp_ep_params_field(128);
}
impl ucp_ep_params_field {
    pub const UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR: ucp_ep_params_field = ucp_ep_params_field(256);
}
impl ::std::ops::BitOr<ucp_ep_params_field> for ucp_ep_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_ep_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_ep_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_ep_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_ep_params_field> for ucp_ep_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_ep_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_ep_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_ep_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_ep_params_field(pub ::std::os::raw::c_uint);
impl ucp_ep_params_flags_field {
    pub const UCP_EP_PARAMS_FLAGS_CLIENT_SERVER: ucp_ep_params_flags_field =
        ucp_ep_params_flags_field(1);
}
impl ucp_ep_params_flags_field {
    pub const UCP_EP_PARAMS_FLAGS_NO_LOOPBACK: ucp_ep_params_flags_field =
        ucp_ep_params_flags_field(2);
}
impl ucp_ep_params_flags_field {
    pub const UCP_EP_PARAMS_FLAGS_SEND_CLIENT_ID: ucp_ep_params_flags_field =
        ucp_ep_params_flags_field(4);
}
impl ::std::ops::BitOr<ucp_ep_params_flags_field> for ucp_ep_params_flags_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_ep_params_flags_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_ep_params_flags_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_ep_params_flags_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_ep_params_flags_field> for ucp_ep_params_flags_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_ep_params_flags_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_ep_params_flags_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_ep_params_flags_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_ep_params_flags_field(pub ::std::os::raw::c_uint);
impl ucp_ep_close_flags_t {
    pub const UCP_EP_CLOSE_FLAG_FORCE: ucp_ep_close_flags_t = ucp_ep_close_flags_t(1);
}
impl ::std::ops::BitOr<ucp_ep_close_flags_t> for ucp_ep_close_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_ep_close_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_ep_close_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_ep_close_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_ep_close_flags_t> for ucp_ep_close_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_ep_close_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_ep_close_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_ep_close_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_ep_close_flags_t(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_ep_close_mode {
    UCP_EP_CLOSE_MODE_FORCE = 0,
    UCP_EP_CLOSE_MODE_FLUSH = 1,
}
impl ucp_ep_perf_param_field {
    pub const UCP_EP_PERF_PARAM_FIELD_MESSAGE_SIZE: ucp_ep_perf_param_field =
        ucp_ep_perf_param_field(1);
}
impl ::std::ops::BitOr<ucp_ep_perf_param_field> for ucp_ep_perf_param_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_ep_perf_param_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_ep_perf_param_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_ep_perf_param_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_ep_perf_param_field> for ucp_ep_perf_param_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_ep_perf_param_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_ep_perf_param_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_ep_perf_param_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_ep_perf_param_field(pub ::std::os::raw::c_uint);
pub use self::ucp_ep_perf_param_field as ucp_ep_perf_param_field_t;
impl ucp_ep_perf_attr_field {
    pub const UCP_EP_PERF_ATTR_FIELD_ESTIMATED_TIME: ucp_ep_perf_attr_field =
        ucp_ep_perf_attr_field(1);
}
impl ::std::ops::BitOr<ucp_ep_perf_attr_field> for ucp_ep_perf_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_ep_perf_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_ep_perf_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_ep_perf_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_ep_perf_attr_field> for ucp_ep_perf_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_ep_perf_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_ep_perf_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_ep_perf_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_ep_perf_attr_field(pub ::std::os::raw::c_uint);
pub use self::ucp_ep_perf_attr_field as ucp_ep_perf_attr_field_t;
impl ucp_mem_map_params_field {
    pub const UCP_MEM_MAP_PARAM_FIELD_ADDRESS: ucp_mem_map_params_field =
        ucp_mem_map_params_field(1);
}
impl ucp_mem_map_params_field {
    pub const UCP_MEM_MAP_PARAM_FIELD_LENGTH: ucp_mem_map_params_field =
        ucp_mem_map_params_field(2);
}
impl ucp_mem_map_params_field {
    pub const UCP_MEM_MAP_PARAM_FIELD_FLAGS: ucp_mem_map_params_field = ucp_mem_map_params_field(4);
}
impl ucp_mem_map_params_field {
    pub const UCP_MEM_MAP_PARAM_FIELD_PROT: ucp_mem_map_params_field = ucp_mem_map_params_field(8);
}
impl ucp_mem_map_params_field {
    pub const UCP_MEM_MAP_PARAM_FIELD_MEMORY_TYPE: ucp_mem_map_params_field =
        ucp_mem_map_params_field(16);
}
impl ucp_mem_map_params_field {
    pub const UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER: ucp_mem_map_params_field =
        ucp_mem_map_params_field(32);
}
impl ::std::ops::BitOr<ucp_mem_map_params_field> for ucp_mem_map_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_mem_map_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_mem_map_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_mem_map_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_mem_map_params_field> for ucp_mem_map_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_mem_map_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_mem_map_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_mem_map_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_mem_map_params_field(pub ::std::os::raw::c_uint);
impl ucp_mem_advise_params_field {
    pub const UCP_MEM_ADVISE_PARAM_FIELD_ADDRESS: ucp_mem_advise_params_field =
        ucp_mem_advise_params_field(1);
}
impl ucp_mem_advise_params_field {
    pub const UCP_MEM_ADVISE_PARAM_FIELD_LENGTH: ucp_mem_advise_params_field =
        ucp_mem_advise_params_field(2);
}
impl ucp_mem_advise_params_field {
    pub const UCP_MEM_ADVISE_PARAM_FIELD_ADVICE: ucp_mem_advise_params_field =
        ucp_mem_advise_params_field(4);
}
impl ::std::ops::BitOr<ucp_mem_advise_params_field> for ucp_mem_advise_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_mem_advise_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_mem_advise_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_mem_advise_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_mem_advise_params_field> for ucp_mem_advise_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_mem_advise_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_mem_advise_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_mem_advise_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_mem_advise_params_field(pub ::std::os::raw::c_uint);
impl ucp_lib_attr_field {
    pub const UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL: ucp_lib_attr_field = ucp_lib_attr_field(1);
}
impl ::std::ops::BitOr<ucp_lib_attr_field> for ucp_lib_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_lib_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_lib_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_lib_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_lib_attr_field> for ucp_lib_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_lib_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_lib_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_lib_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_lib_attr_field(pub ::std::os::raw::c_uint);
impl ucp_context_attr_field {
    pub const UCP_ATTR_FIELD_REQUEST_SIZE: ucp_context_attr_field = ucp_context_attr_field(1);
}
impl ucp_context_attr_field {
    pub const UCP_ATTR_FIELD_THREAD_MODE: ucp_context_attr_field = ucp_context_attr_field(2);
}
impl ucp_context_attr_field {
    pub const UCP_ATTR_FIELD_MEMORY_TYPES: ucp_context_attr_field = ucp_context_attr_field(4);
}
impl ucp_context_attr_field {
    pub const UCP_ATTR_FIELD_NAME: ucp_context_attr_field = ucp_context_attr_field(8);
}
impl ::std::ops::BitOr<ucp_context_attr_field> for ucp_context_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_context_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_context_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_context_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_context_attr_field> for ucp_context_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_context_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_context_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_context_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_context_attr_field(pub ::std::os::raw::c_uint);
impl ucp_worker_attr_field {
    pub const UCP_WORKER_ATTR_FIELD_THREAD_MODE: ucp_worker_attr_field = ucp_worker_attr_field(1);
}
impl ucp_worker_attr_field {
    pub const UCP_WORKER_ATTR_FIELD_ADDRESS: ucp_worker_attr_field = ucp_worker_attr_field(2);
}
impl ucp_worker_attr_field {
    pub const UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS: ucp_worker_attr_field = ucp_worker_attr_field(4);
}
impl ucp_worker_attr_field {
    pub const UCP_WORKER_ATTR_FIELD_MAX_AM_HEADER: ucp_worker_attr_field = ucp_worker_attr_field(8);
}
impl ucp_worker_attr_field {
    pub const UCP_WORKER_ATTR_FIELD_NAME: ucp_worker_attr_field = ucp_worker_attr_field(16);
}
impl ucp_worker_attr_field {
    pub const UCP_WORKER_ATTR_FIELD_MAX_INFO_STRING: ucp_worker_attr_field =
        ucp_worker_attr_field(32);
}
impl ::std::ops::BitOr<ucp_worker_attr_field> for ucp_worker_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_worker_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_worker_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_worker_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_worker_attr_field> for ucp_worker_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_worker_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_worker_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_worker_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_worker_attr_field(pub ::std::os::raw::c_uint);
impl ucp_worker_address_attr_field {
    pub const UCP_WORKER_ADDRESS_ATTR_FIELD_UID: ucp_worker_address_attr_field =
        ucp_worker_address_attr_field(1);
}
impl ::std::ops::BitOr<ucp_worker_address_attr_field> for ucp_worker_address_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_worker_address_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_worker_address_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_worker_address_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_worker_address_attr_field> for ucp_worker_address_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_worker_address_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_worker_address_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_worker_address_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_worker_address_attr_field(pub ::std::os::raw::c_uint);
impl ucp_listener_attr_field {
    pub const UCP_LISTENER_ATTR_FIELD_SOCKADDR: ucp_listener_attr_field =
        ucp_listener_attr_field(1);
}
impl ::std::ops::BitOr<ucp_listener_attr_field> for ucp_listener_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_listener_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_listener_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_listener_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_listener_attr_field> for ucp_listener_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_listener_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_listener_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_listener_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_listener_attr_field(pub ::std::os::raw::c_uint);
impl ucp_conn_request_attr_field {
    pub const UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR: ucp_conn_request_attr_field =
        ucp_conn_request_attr_field(1);
}
impl ucp_conn_request_attr_field {
    pub const UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ID: ucp_conn_request_attr_field =
        ucp_conn_request_attr_field(2);
}
impl ::std::ops::BitOr<ucp_conn_request_attr_field> for ucp_conn_request_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_conn_request_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_conn_request_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_conn_request_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_conn_request_attr_field> for ucp_conn_request_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_conn_request_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_conn_request_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_conn_request_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_conn_request_attr_field(pub ::std::os::raw::c_uint);
impl ucp_dt_type {
    pub const UCP_DATATYPE_CLASS_MASK: ucp_dt_type = ucp_dt_type::UCP_DATATYPE_GENERIC;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_dt_type {
    UCP_DATATYPE_CONTIG = 0,
    UCP_DATATYPE_STRIDED = 1,
    UCP_DATATYPE_IOV = 2,
    UCP_DATATYPE_GENERIC = 7,
    UCP_DATATYPE_SHIFT = 3,
}
impl ucp_datatype_attr_field {
    pub const UCP_DATATYPE_ATTR_FIELD_PACKED_SIZE: ucp_datatype_attr_field =
        ucp_datatype_attr_field(1);
}
impl ucp_datatype_attr_field {
    pub const UCP_DATATYPE_ATTR_FIELD_BUFFER: ucp_datatype_attr_field = ucp_datatype_attr_field(2);
}
impl ucp_datatype_attr_field {
    pub const UCP_DATATYPE_ATTR_FIELD_COUNT: ucp_datatype_attr_field = ucp_datatype_attr_field(4);
}
impl ::std::ops::BitOr<ucp_datatype_attr_field> for ucp_datatype_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_datatype_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_datatype_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_datatype_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_datatype_attr_field> for ucp_datatype_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_datatype_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_datatype_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_datatype_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_datatype_attr_field(pub ::std::os::raw::c_uint);
pub const UCP_MEM_MAP_NONBLOCK: _bindgen_ty_8 = _bindgen_ty_8::UCP_MEM_MAP_NONBLOCK;
pub const UCP_MEM_MAP_ALLOCATE: _bindgen_ty_8 = _bindgen_ty_8::UCP_MEM_MAP_ALLOCATE;
pub const UCP_MEM_MAP_FIXED: _bindgen_ty_8 = _bindgen_ty_8::UCP_MEM_MAP_FIXED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    UCP_MEM_MAP_NONBLOCK = 1,
    UCP_MEM_MAP_ALLOCATE = 2,
    UCP_MEM_MAP_FIXED = 4,
}
pub const UCP_MEM_MAP_PROT_LOCAL_READ: _bindgen_ty_9 = _bindgen_ty_9::UCP_MEM_MAP_PROT_LOCAL_READ;
pub const UCP_MEM_MAP_PROT_LOCAL_WRITE: _bindgen_ty_9 = _bindgen_ty_9::UCP_MEM_MAP_PROT_LOCAL_WRITE;
pub const UCP_MEM_MAP_PROT_REMOTE_READ: _bindgen_ty_9 = _bindgen_ty_9::UCP_MEM_MAP_PROT_REMOTE_READ;
pub const UCP_MEM_MAP_PROT_REMOTE_WRITE: _bindgen_ty_9 =
    _bindgen_ty_9::UCP_MEM_MAP_PROT_REMOTE_WRITE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_9 {
    UCP_MEM_MAP_PROT_LOCAL_READ = 1,
    UCP_MEM_MAP_PROT_LOCAL_WRITE = 2,
    UCP_MEM_MAP_PROT_REMOTE_READ = 256,
    UCP_MEM_MAP_PROT_REMOTE_WRITE = 512,
}
impl ucp_am_cb_flags {
    pub const UCP_AM_FLAG_WHOLE_MSG: ucp_am_cb_flags = ucp_am_cb_flags(1);
}
impl ucp_am_cb_flags {
    pub const UCP_AM_FLAG_PERSISTENT_DATA: ucp_am_cb_flags = ucp_am_cb_flags(2);
}
impl ::std::ops::BitOr<ucp_am_cb_flags> for ucp_am_cb_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_am_cb_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_am_cb_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_am_cb_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_am_cb_flags> for ucp_am_cb_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_am_cb_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_am_cb_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_am_cb_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_am_cb_flags(pub ::std::os::raw::c_uint);
impl ucp_send_am_flags {
    pub const UCP_AM_SEND_FLAG_REPLY: ucp_send_am_flags = ucp_send_am_flags(1);
}
impl ucp_send_am_flags {
    pub const UCP_AM_SEND_FLAG_EAGER: ucp_send_am_flags = ucp_send_am_flags(2);
}
impl ucp_send_am_flags {
    pub const UCP_AM_SEND_FLAG_RNDV: ucp_send_am_flags = ucp_send_am_flags(4);
}
impl ucp_send_am_flags {
    pub const UCP_AM_SEND_FLAG_COPY_HEADER: ucp_send_am_flags = ucp_send_am_flags(8);
}
impl ucp_send_am_flags {
    pub const UCP_AM_SEND_REPLY: ucp_send_am_flags = ucp_send_am_flags(1);
}
impl ::std::ops::BitOr<ucp_send_am_flags> for ucp_send_am_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_send_am_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_send_am_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_send_am_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_send_am_flags> for ucp_send_am_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_send_am_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_send_am_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_send_am_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_send_am_flags(pub ::std::os::raw::c_uint);
impl ucp_cb_param_flags {
    pub const UCP_CB_PARAM_FLAG_DATA: ucp_cb_param_flags = ucp_cb_param_flags(1);
}
impl ::std::ops::BitOr<ucp_cb_param_flags> for ucp_cb_param_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_cb_param_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_cb_param_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_cb_param_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_cb_param_flags> for ucp_cb_param_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_cb_param_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_cb_param_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_cb_param_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_cb_param_flags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_atomic_op_t {
    UCP_ATOMIC_OP_ADD = 0,
    UCP_ATOMIC_OP_SWAP = 1,
    UCP_ATOMIC_OP_CSWAP = 2,
    UCP_ATOMIC_OP_AND = 3,
    UCP_ATOMIC_OP_OR = 4,
    UCP_ATOMIC_OP_XOR = 5,
    UCP_ATOMIC_OP_LAST = 6,
}
impl ucp_stream_recv_flags_t {
    pub const UCP_STREAM_RECV_FLAG_WAITALL: ucp_stream_recv_flags_t = ucp_stream_recv_flags_t(1);
}
impl ::std::ops::BitOr<ucp_stream_recv_flags_t> for ucp_stream_recv_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_stream_recv_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_stream_recv_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_stream_recv_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_stream_recv_flags_t> for ucp_stream_recv_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_stream_recv_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_stream_recv_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_stream_recv_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_stream_recv_flags_t(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_op_attr_t {
    UCP_OP_ATTR_FIELD_REQUEST = 1,
    UCP_OP_ATTR_FIELD_CALLBACK = 2,
    UCP_OP_ATTR_FIELD_USER_DATA = 4,
    UCP_OP_ATTR_FIELD_DATATYPE = 8,
    UCP_OP_ATTR_FIELD_FLAGS = 16,
    UCP_OP_ATTR_FIELD_REPLY_BUFFER = 32,
    UCP_OP_ATTR_FIELD_MEMORY_TYPE = 64,
    UCP_OP_ATTR_FIELD_RECV_INFO = 128,
    UCP_OP_ATTR_FIELD_MEMH = 256,
    UCP_OP_ATTR_FLAG_NO_IMM_CMPL = 65536,
    UCP_OP_ATTR_FLAG_FAST_CMPL = 131072,
    UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL = 262144,
    UCP_OP_ATTR_FLAG_MULTI_SEND = 524288,
}
impl ucp_req_attr_field {
    pub const UCP_REQUEST_ATTR_FIELD_INFO_STRING: ucp_req_attr_field = ucp_req_attr_field(1);
}
impl ucp_req_attr_field {
    pub const UCP_REQUEST_ATTR_FIELD_INFO_STRING_SIZE: ucp_req_attr_field = ucp_req_attr_field(2);
}
impl ucp_req_attr_field {
    pub const UCP_REQUEST_ATTR_FIELD_STATUS: ucp_req_attr_field = ucp_req_attr_field(4);
}
impl ucp_req_attr_field {
    pub const UCP_REQUEST_ATTR_FIELD_MEM_TYPE: ucp_req_attr_field = ucp_req_attr_field(8);
}
impl ::std::ops::BitOr<ucp_req_attr_field> for ucp_req_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_req_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_req_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_req_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_req_attr_field> for ucp_req_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_req_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_req_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_req_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_req_attr_field(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_am_recv_attr_t {
    UCP_AM_RECV_ATTR_FIELD_REPLY_EP = 1,
    UCP_AM_RECV_ATTR_FLAG_DATA = 65536,
    UCP_AM_RECV_ATTR_FLAG_RNDV = 131072,
}
impl ucp_am_handler_param_field {
    pub const UCP_AM_HANDLER_PARAM_FIELD_ID: ucp_am_handler_param_field =
        ucp_am_handler_param_field(1);
}
impl ucp_am_handler_param_field {
    pub const UCP_AM_HANDLER_PARAM_FIELD_FLAGS: ucp_am_handler_param_field =
        ucp_am_handler_param_field(2);
}
impl ucp_am_handler_param_field {
    pub const UCP_AM_HANDLER_PARAM_FIELD_CB: ucp_am_handler_param_field =
        ucp_am_handler_param_field(4);
}
impl ucp_am_handler_param_field {
    pub const UCP_AM_HANDLER_PARAM_FIELD_ARG: ucp_am_handler_param_field =
        ucp_am_handler_param_field(8);
}
impl ::std::ops::BitOr<ucp_am_handler_param_field> for ucp_am_handler_param_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_am_handler_param_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_am_handler_param_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_am_handler_param_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_am_handler_param_field> for ucp_am_handler_param_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_am_handler_param_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_am_handler_param_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_am_handler_param_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_am_handler_param_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_dt_iov {
    pub buffer: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_ucp_dt_iov() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_dt_iov> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_dt_iov>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_dt_iov))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_dt_iov>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_dt_iov))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_dt_iov),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_dt_iov),
            "::",
            stringify!(length)
        )
    );
}
pub type ucp_dt_iov_t = ucp_dt_iov;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_generic_dt_ops {
    pub start_pack: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            buffer: *const ::std::os::raw::c_void,
            count: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub start_unpack: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_void,
            count: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub packed_size:
        ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void) -> usize>,
    pub pack: ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut ::std::os::raw::c_void,
            offset: usize,
            dest: *mut ::std::os::raw::c_void,
            max_length: usize,
        ) -> usize,
    >,
    pub unpack: ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut ::std::os::raw::c_void,
            offset: usize,
            src: *const ::std::os::raw::c_void,
            length: usize,
        ) -> ucs_status_t,
    >,
    pub finish: ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_ucp_generic_dt_ops() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_generic_dt_ops> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_generic_dt_ops>(),
        48usize,
        concat!("Size of: ", stringify!(ucp_generic_dt_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_generic_dt_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_generic_dt_ops))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_pack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_generic_dt_ops),
            "::",
            stringify!(start_pack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_unpack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_generic_dt_ops),
            "::",
            stringify!(start_unpack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packed_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_generic_dt_ops),
            "::",
            stringify!(packed_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pack) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_generic_dt_ops),
            "::",
            stringify!(pack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unpack) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_generic_dt_ops),
            "::",
            stringify!(unpack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_generic_dt_ops),
            "::",
            stringify!(finish)
        )
    );
}
pub type ucp_generic_dt_ops_t = ucp_generic_dt_ops;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_datatype_attr {
    pub field_mask: u64,
    pub packed_size: usize,
    pub buffer: *const ::std::os::raw::c_void,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_ucp_datatype_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_datatype_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_datatype_attr>(),
        32usize,
        concat!("Size of: ", stringify!(ucp_datatype_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_datatype_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_datatype_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_datatype_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packed_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_datatype_attr),
            "::",
            stringify!(packed_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_datatype_attr),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_datatype_attr),
            "::",
            stringify!(count)
        )
    );
}
pub type ucp_datatype_attr_t = ucp_datatype_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_params {
    pub field_mask: u64,
    pub features: u64,
    pub request_size: usize,
    pub request_init: ucp_request_init_callback_t,
    pub request_cleanup: ucp_request_cleanup_callback_t,
    pub tag_sender_mask: u64,
    pub mt_workers_shared: ::std::os::raw::c_int,
    pub estimated_num_eps: usize,
    pub estimated_num_ppn: usize,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ucp_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_params>(),
        80usize,
        concat!("Size of: ", stringify!(ucp_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(request_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_init) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(request_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_cleanup) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(request_cleanup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_sender_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(tag_sender_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mt_workers_shared) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(mt_workers_shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).estimated_num_eps) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(estimated_num_eps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).estimated_num_ppn) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(estimated_num_ppn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_params),
            "::",
            stringify!(name)
        )
    );
}
pub type ucp_params_t = ucp_params;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_lib_attr {
    pub field_mask: u64,
    pub max_thread_level: ucs_thread_mode_t,
}
#[test]
fn bindgen_test_layout_ucp_lib_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_lib_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_lib_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_lib_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_lib_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_lib_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_lib_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_thread_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_lib_attr),
            "::",
            stringify!(max_thread_level)
        )
    );
}
pub type ucp_lib_attr_t = ucp_lib_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_context_attr {
    pub field_mask: u64,
    pub request_size: usize,
    pub thread_mode: ucs_thread_mode_t,
    pub memory_types: u64,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_ucp_context_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_context_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_context_attr>(),
        64usize,
        concat!("Size of: ", stringify!(ucp_context_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_context_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_context_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_context_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_context_attr),
            "::",
            stringify!(request_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_context_attr),
            "::",
            stringify!(thread_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_types) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_context_attr),
            "::",
            stringify!(memory_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_context_attr),
            "::",
            stringify!(name)
        )
    );
}
pub type ucp_context_attr_t = ucp_context_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_worker_attr {
    pub field_mask: u64,
    pub thread_mode: ucs_thread_mode_t,
    pub address_flags: u32,
    pub address: *mut ucp_address_t,
    pub address_length: usize,
    pub max_am_header: usize,
    pub name: [::std::os::raw::c_char; 32usize],
    pub max_debug_string: usize,
}
#[test]
fn bindgen_test_layout_ucp_worker_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_worker_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_worker_attr>(),
        80usize,
        concat!("Size of: ", stringify!(ucp_worker_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_worker_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_worker_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(thread_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(address_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(address_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_am_header) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(max_am_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_debug_string) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_attr),
            "::",
            stringify!(max_debug_string)
        )
    );
}
pub type ucp_worker_attr_t = ucp_worker_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_worker_params {
    pub field_mask: u64,
    pub thread_mode: ucs_thread_mode_t,
    pub cpu_mask: ucs_cpu_set_t,
    pub events: ::std::os::raw::c_uint,
    pub user_data: *mut ::std::os::raw::c_void,
    pub event_fd: ::std::os::raw::c_int,
    pub flags: u64,
    pub name: *const ::std::os::raw::c_char,
    pub am_alignment: usize,
    pub client_id: u64,
}
#[test]
fn bindgen_test_layout_ucp_worker_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_worker_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_worker_params>(),
        200usize,
        concat!("Size of: ", stringify!(ucp_worker_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_worker_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_worker_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(thread_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(cpu_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_fd) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(event_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).am_alignment) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(am_alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_params),
            "::",
            stringify!(client_id)
        )
    );
}
pub type ucp_worker_params_t = ucp_worker_params;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_worker_address_attr {
    pub field_mask: u64,
    pub worker_uid: u64,
}
#[test]
fn bindgen_test_layout_ucp_worker_address_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_worker_address_attr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_worker_address_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_worker_address_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_worker_address_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_worker_address_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_address_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).worker_uid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_worker_address_attr),
            "::",
            stringify!(worker_uid)
        )
    );
}
pub type ucp_worker_address_attr_t = ucp_worker_address_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_ep_evaluate_perf_param_t {
    pub field_mask: u64,
    pub message_size: usize,
}
#[test]
fn bindgen_test_layout_ucp_ep_evaluate_perf_param_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_ep_evaluate_perf_param_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_ep_evaluate_perf_param_t>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_ep_evaluate_perf_param_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_ep_evaluate_perf_param_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_ep_evaluate_perf_param_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_evaluate_perf_param_t),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_evaluate_perf_param_t),
            "::",
            stringify!(message_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_ep_evaluate_perf_attr_t {
    pub field_mask: u64,
    pub estimated_time: f64,
}
#[test]
fn bindgen_test_layout_ucp_ep_evaluate_perf_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_ep_evaluate_perf_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_ep_evaluate_perf_attr_t>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_ep_evaluate_perf_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_ep_evaluate_perf_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_ep_evaluate_perf_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_evaluate_perf_attr_t),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).estimated_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_evaluate_perf_attr_t),
            "::",
            stringify!(estimated_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_listener_attr {
    pub field_mask: u64,
    pub sockaddr: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_ucp_listener_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_listener_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_listener_attr>(),
        136usize,
        concat!("Size of: ", stringify!(ucp_listener_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_listener_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_listener_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_attr),
            "::",
            stringify!(sockaddr)
        )
    );
}
pub type ucp_listener_attr_t = ucp_listener_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_conn_request_attr {
    pub field_mask: u64,
    pub client_address: sockaddr_storage,
    pub client_id: u64,
}
#[test]
fn bindgen_test_layout_ucp_conn_request_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_conn_request_attr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_conn_request_attr>(),
        144usize,
        concat!("Size of: ", stringify!(ucp_conn_request_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_conn_request_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_conn_request_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_conn_request_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_conn_request_attr),
            "::",
            stringify!(client_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_conn_request_attr),
            "::",
            stringify!(client_id)
        )
    );
}
pub type ucp_conn_request_attr_t = ucp_conn_request_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_listener_params {
    pub field_mask: u64,
    pub sockaddr: ucs_sock_addr_t,
    pub accept_handler: ucp_listener_accept_handler_t,
    pub conn_handler: ucp_listener_conn_handler_t,
}
#[test]
fn bindgen_test_layout_ucp_listener_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_listener_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_listener_params>(),
        56usize,
        concat!("Size of: ", stringify!(ucp_listener_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_listener_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_listener_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sockaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_params),
            "::",
            stringify!(sockaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept_handler) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_params),
            "::",
            stringify!(accept_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_handler) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_listener_params),
            "::",
            stringify!(conn_handler)
        )
    );
}
pub type ucp_listener_params_t = ucp_listener_params;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_stream_poll_ep {
    pub ep: ucp_ep_h,
    pub user_data: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ucp_stream_poll_ep() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_stream_poll_ep> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_stream_poll_ep>(),
        40usize,
        concat!("Size of: ", stringify!(ucp_stream_poll_ep))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_stream_poll_ep>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_stream_poll_ep))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ep) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_stream_poll_ep),
            "::",
            stringify!(ep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_stream_poll_ep),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_stream_poll_ep),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_stream_poll_ep),
            "::",
            stringify!(reserved)
        )
    );
}
pub type ucp_stream_poll_ep_t = ucp_stream_poll_ep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_mem_map_params {
    pub field_mask: u64,
    pub address: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub flags: ::std::os::raw::c_uint,
    pub prot: ::std::os::raw::c_uint,
    pub memory_type: ucs_memory_type_t,
    pub exported_memh_buffer: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucp_mem_map_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_mem_map_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_mem_map_params>(),
        48usize,
        concat!("Size of: ", stringify!(ucp_mem_map_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_mem_map_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_mem_map_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_map_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_map_params),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_map_params),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_map_params),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prot) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_map_params),
            "::",
            stringify!(prot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_map_params),
            "::",
            stringify!(memory_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exported_memh_buffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_map_params),
            "::",
            stringify!(exported_memh_buffer)
        )
    );
}
pub type ucp_mem_map_params_t = ucp_mem_map_params;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_tag_recv_info {
    pub sender_tag: ucp_tag_t,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_ucp_tag_recv_info() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_tag_recv_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_tag_recv_info>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_tag_recv_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_tag_recv_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_tag_recv_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_tag_recv_info),
            "::",
            stringify!(sender_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_tag_recv_info),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucp_request_param_t {
    pub op_attr_mask: u32,
    pub flags: u32,
    pub request: *mut ::std::os::raw::c_void,
    pub cb: ucp_request_param_t__bindgen_ty_1,
    pub datatype: ucp_datatype_t,
    pub user_data: *mut ::std::os::raw::c_void,
    pub reply_buffer: *mut ::std::os::raw::c_void,
    pub memory_type: ucs_memory_type_t,
    pub recv_info: ucp_request_param_t__bindgen_ty_2,
    pub memh: ucp_mem_h,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ucp_request_param_t__bindgen_ty_1 {
    pub send: ucp_send_nbx_callback_t,
    pub recv: ucp_tag_recv_nbx_callback_t,
    pub recv_stream: ucp_stream_recv_nbx_callback_t,
    pub recv_am: ucp_am_recv_data_nbx_callback_t,
}
#[test]
fn bindgen_test_layout_ucp_request_param_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_request_param_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_request_param_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ucp_request_param_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_request_param_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ucp_request_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t__bindgen_ty_1),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t__bindgen_ty_1),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t__bindgen_ty_1),
            "::",
            stringify!(recv_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_am) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t__bindgen_ty_1),
            "::",
            stringify!(recv_am)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ucp_request_param_t__bindgen_ty_2 {
    pub length: *mut usize,
    pub tag_info: *mut ucp_tag_recv_info_t,
}
#[test]
fn bindgen_test_layout_ucp_request_param_t__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_request_param_t__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_request_param_t__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(ucp_request_param_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_request_param_t__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ucp_request_param_t__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t__bindgen_ty_2),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t__bindgen_ty_2),
            "::",
            stringify!(tag_info)
        )
    );
}
#[test]
fn bindgen_test_layout_ucp_request_param_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_request_param_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_request_param_t>(),
        72usize,
        concat!("Size of: ", stringify!(ucp_request_param_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_request_param_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_request_param_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_attr_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(op_attr_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datatype) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(datatype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reply_buffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(reply_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(memory_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_info) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(recv_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memh) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_param_t),
            "::",
            stringify!(memh)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_request_attr_t {
    pub field_mask: u64,
    pub debug_string: *mut ::std::os::raw::c_char,
    pub debug_string_size: usize,
    pub status: ucs_status_t,
    pub mem_type: ucs_memory_type_t,
}
#[test]
fn bindgen_test_layout_ucp_request_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_request_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_request_attr_t>(),
        32usize,
        concat!("Size of: ", stringify!(ucp_request_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_request_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_request_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_attr_t),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug_string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_attr_t),
            "::",
            stringify!(debug_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug_string_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_attr_t),
            "::",
            stringify!(debug_string_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_attr_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_request_attr_t),
            "::",
            stringify!(mem_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_am_handler_param {
    pub field_mask: u64,
    pub id: ::std::os::raw::c_uint,
    pub flags: u32,
    pub cb: ucp_am_recv_callback_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucp_am_handler_param() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_am_handler_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_am_handler_param>(),
        32usize,
        concat!("Size of: ", stringify!(ucp_am_handler_param))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_am_handler_param>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_am_handler_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_am_handler_param),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_am_handler_param),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_am_handler_param),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_am_handler_param),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_am_handler_param),
            "::",
            stringify!(arg)
        )
    );
}
pub type ucp_am_handler_param_t = ucp_am_handler_param;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_am_recv_param {
    pub recv_attr: u64,
    pub reply_ep: ucp_ep_h,
}
#[test]
fn bindgen_test_layout_ucp_am_recv_param() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_am_recv_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_am_recv_param>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_am_recv_param))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_am_recv_param>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_am_recv_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_am_recv_param),
            "::",
            stringify!(recv_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reply_ep) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_am_recv_param),
            "::",
            stringify!(reply_ep)
        )
    );
}
extern "C" {
    pub fn ucp_lib_query(attr: *mut ucp_lib_attr_t) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_config_read(
        env_prefix: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        config_p: *mut *mut ucp_config_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_config_release(config: *mut ucp_config_t);
}
extern "C" {
    pub fn ucp_config_modify(
        config: *mut ucp_config_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_config_print(
        config: *const ucp_config_t,
        stream: *mut FILE,
        title: *const ::std::os::raw::c_char,
        print_flags: ucs_config_print_flags_t,
    );
}
extern "C" {
    pub fn ucp_get_version(
        major_version: *mut ::std::os::raw::c_uint,
        minor_version: *mut ::std::os::raw::c_uint,
        release_number: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn ucp_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucp_init_version(
        api_major_version: ::std::os::raw::c_uint,
        api_minor_version: ::std::os::raw::c_uint,
        params: *const ucp_params_t,
        config: *const ucp_config_t,
        context_p: *mut ucp_context_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_cleanup(context_p: ucp_context_h);
}
extern "C" {
    pub fn ucp_context_query(
        context_p: ucp_context_h,
        attr: *mut ucp_context_attr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_context_print_info(context: ucp_context_h, stream: *mut FILE);
}
extern "C" {
    pub fn ucp_worker_create(
        context: ucp_context_h,
        params: *const ucp_worker_params_t,
        worker_p: *mut ucp_worker_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_destroy(worker: ucp_worker_h);
}
extern "C" {
    pub fn ucp_worker_query(worker: ucp_worker_h, attr: *mut ucp_worker_attr_t) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_print_info(worker: ucp_worker_h, stream: *mut FILE);
}
extern "C" {
    pub fn ucp_worker_release_address(worker: ucp_worker_h, address: *mut ucp_address_t);
}
extern "C" {
    pub fn ucp_worker_address_query(
        address: *mut ucp_address_t,
        attr: *mut ucp_worker_address_attr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_progress(worker: ucp_worker_h) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ucp_stream_worker_poll(
        worker: ucp_worker_h,
        poll_eps: *mut ucp_stream_poll_ep_t,
        max_eps: usize,
        flags: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn ucp_worker_get_efd(worker: ucp_worker_h, fd: *mut ::std::os::raw::c_int)
        -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_wait(worker: ucp_worker_h) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_wait_mem(worker: ucp_worker_h, address: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ucp_worker_arm(worker: ucp_worker_h) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_signal(worker: ucp_worker_h) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_listener_create(
        worker: ucp_worker_h,
        params: *const ucp_listener_params_t,
        listener_p: *mut ucp_listener_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_listener_destroy(listener: ucp_listener_h);
}
extern "C" {
    pub fn ucp_listener_query(
        listener: ucp_listener_h,
        attr: *mut ucp_listener_attr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_conn_request_query(
        conn_request: ucp_conn_request_h,
        attr: *mut ucp_conn_request_attr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_request_query(
        request: *mut ::std::os::raw::c_void,
        attr: *mut ucp_request_attr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_ep_create(
        worker: ucp_worker_h,
        params: *const ucp_ep_params_t,
        ep_p: *mut ucp_ep_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_ep_close_nbx(ep: ucp_ep_h, param: *const ucp_request_param_t) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_listener_reject(
        listener: ucp_listener_h,
        conn_request: ucp_conn_request_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_ep_print_info(ep: ucp_ep_h, stream: *mut FILE);
}
extern "C" {
    pub fn ucp_ep_flush_nbx(ep: ucp_ep_h, param: *const ucp_request_param_t) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_ep_evaluate_perf(
        ep: ucp_ep_h,
        param: *const ucp_ep_evaluate_perf_param_t,
        attr: *mut ucp_ep_evaluate_perf_attr_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_mem_map(
        context: ucp_context_h,
        params: *const ucp_mem_map_params_t,
        memh_p: *mut ucp_mem_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_mem_unmap(context: ucp_context_h, memh: ucp_mem_h) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_mem_query(memh: ucp_mem_h, attr: *mut ucp_mem_attr_t) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_mem_print_info(
        mem_spec: *const ::std::os::raw::c_char,
        context: ucp_context_h,
        stream: *mut FILE,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucp_mem_advice {
    UCP_MADV_NORMAL = 0,
    UCP_MADV_WILLNEED = 1,
}
pub use self::ucp_mem_advice as ucp_mem_advice_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_mem_advise_params {
    pub field_mask: u64,
    pub address: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub advice: ucp_mem_advice_t,
}
#[test]
fn bindgen_test_layout_ucp_mem_advise_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_mem_advise_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_mem_advise_params>(),
        32usize,
        concat!("Size of: ", stringify!(ucp_mem_advise_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_mem_advise_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_mem_advise_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_advise_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_advise_params),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_advise_params),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advice) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_mem_advise_params),
            "::",
            stringify!(advice)
        )
    );
}
pub type ucp_mem_advise_params_t = ucp_mem_advise_params;
extern "C" {
    pub fn ucp_mem_advise(
        context: ucp_context_h,
        memh: ucp_mem_h,
        params: *mut ucp_mem_advise_params_t,
    ) -> ucs_status_t;
}
impl ucp_memh_pack_params_field {
    pub const UCP_MEMH_PACK_PARAM_FIELD_FLAGS: ucp_memh_pack_params_field =
        ucp_memh_pack_params_field(1);
}
impl ::std::ops::BitOr<ucp_memh_pack_params_field> for ucp_memh_pack_params_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_memh_pack_params_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_memh_pack_params_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_memh_pack_params_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_memh_pack_params_field> for ucp_memh_pack_params_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_memh_pack_params_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_memh_pack_params_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_memh_pack_params_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_memh_pack_params_field(pub ::std::os::raw::c_uint);
impl ucp_memh_pack_flags {
    pub const UCP_MEMH_PACK_FLAG_EXPORT: ucp_memh_pack_flags = ucp_memh_pack_flags(1);
}
impl ::std::ops::BitOr<ucp_memh_pack_flags> for ucp_memh_pack_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_memh_pack_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_memh_pack_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_memh_pack_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_memh_pack_flags> for ucp_memh_pack_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_memh_pack_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_memh_pack_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_memh_pack_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_memh_pack_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_memh_pack_params {
    pub field_mask: u64,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ucp_memh_pack_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_memh_pack_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_memh_pack_params>(),
        16usize,
        concat!("Size of: ", stringify!(ucp_memh_pack_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_memh_pack_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_memh_pack_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_memh_pack_params),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_memh_pack_params),
            "::",
            stringify!(flags)
        )
    );
}
pub type ucp_memh_pack_params_t = ucp_memh_pack_params;
extern "C" {
    pub fn ucp_memh_pack(
        memh: ucp_mem_h,
        params: *const ucp_memh_pack_params_t,
        buffer_p: *mut *mut ::std::os::raw::c_void,
        buffer_size_p: *mut usize,
    ) -> ucs_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_memh_buffer_release_params {
    pub field_mask: u64,
}
#[test]
fn bindgen_test_layout_ucp_memh_buffer_release_params() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_memh_buffer_release_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_memh_buffer_release_params>(),
        8usize,
        concat!("Size of: ", stringify!(ucp_memh_buffer_release_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_memh_buffer_release_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_memh_buffer_release_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_memh_buffer_release_params),
            "::",
            stringify!(field_mask)
        )
    );
}
pub type ucp_memh_buffer_release_params_t = ucp_memh_buffer_release_params;
extern "C" {
    pub fn ucp_memh_buffer_release(
        buffer: *mut ::std::os::raw::c_void,
        params: *const ucp_memh_buffer_release_params_t,
    );
}
extern "C" {
    pub fn ucp_ep_rkey_unpack(
        ep: ucp_ep_h,
        rkey_buffer: *const ::std::os::raw::c_void,
        rkey_p: *mut ucp_rkey_h,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_rkey_ptr(
        rkey: ucp_rkey_h,
        raddr: u64,
        addr_p: *mut *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_rkey_destroy(rkey: ucp_rkey_h);
}
extern "C" {
    pub fn ucp_worker_set_am_recv_handler(
        worker: ucp_worker_h,
        param: *const ucp_am_handler_param_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_am_send_nbx(
        ep: ucp_ep_h,
        id: ::std::os::raw::c_uint,
        header: *const ::std::os::raw::c_void,
        header_length: usize,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_am_recv_data_nbx(
        worker: ucp_worker_h,
        data_desc: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_am_data_release(worker: ucp_worker_h, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ucp_stream_send_nbx(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_send_nbx(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        tag: ucp_tag_t,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_send_sync_nbx(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        tag: ucp_tag_t,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_stream_recv_nbx(
        ep: ucp_ep_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        length: *mut usize,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_stream_recv_data_nb(ep: ucp_ep_h, length: *mut usize) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_recv_nbx(
        worker: ucp_worker_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        tag: ucp_tag_t,
        tag_mask: ucp_tag_t,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_tag_probe_nb(
        worker: ucp_worker_h,
        tag: ucp_tag_t,
        tag_mask: ucp_tag_t,
        remove: ::std::os::raw::c_int,
        info: *mut ucp_tag_recv_info_t,
    ) -> ucp_tag_message_h;
}
extern "C" {
    pub fn ucp_tag_msg_recv_nbx(
        worker: ucp_worker_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        message: ucp_tag_message_h,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_put_nbx(
        ep: ucp_ep_h,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_get_nbx(
        ep: ucp_ep_h,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_atomic_op_nbx(
        ep: ucp_ep_h,
        opcode: ucp_atomic_op_t,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
        remote_addr: u64,
        rkey: ucp_rkey_h,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
extern "C" {
    pub fn ucp_request_check_status(request: *mut ::std::os::raw::c_void) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_tag_recv_request_test(
        request: *mut ::std::os::raw::c_void,
        info: *mut ucp_tag_recv_info_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_stream_recv_request_test(
        request: *mut ::std::os::raw::c_void,
        length_p: *mut usize,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_request_cancel(worker: ucp_worker_h, request: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ucp_stream_data_release(ep: ucp_ep_h, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ucp_request_free(request: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ucp_request_alloc(worker: ucp_worker_h) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucp_dt_create_generic(
        ops: *const ucp_generic_dt_ops_t,
        context: *mut ::std::os::raw::c_void,
        datatype_p: *mut ucp_datatype_t,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_dt_destroy(datatype: ucp_datatype_t);
}
extern "C" {
    pub fn ucp_dt_query(datatype: ucp_datatype_t, attr: *mut ucp_datatype_attr_t) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_fence(worker: ucp_worker_h) -> ucs_status_t;
}
extern "C" {
    pub fn ucp_worker_flush_nbx(
        worker: ucp_worker_h,
        param: *const ucp_request_param_t,
    ) -> ucs_status_ptr_t;
}
impl ucp_ep_attr_field {
    pub const UCP_EP_ATTR_FIELD_NAME: ucp_ep_attr_field = ucp_ep_attr_field(1);
}
impl ucp_ep_attr_field {
    pub const UCP_EP_ATTR_FIELD_LOCAL_SOCKADDR: ucp_ep_attr_field = ucp_ep_attr_field(2);
}
impl ucp_ep_attr_field {
    pub const UCP_EP_ATTR_FIELD_REMOTE_SOCKADDR: ucp_ep_attr_field = ucp_ep_attr_field(4);
}
impl ucp_ep_attr_field {
    pub const UCP_EP_ATTR_FIELD_TRANSPORTS: ucp_ep_attr_field = ucp_ep_attr_field(8);
}
impl ::std::ops::BitOr<ucp_ep_attr_field> for ucp_ep_attr_field {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucp_ep_attr_field(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucp_ep_attr_field {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucp_ep_attr_field) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucp_ep_attr_field> for ucp_ep_attr_field {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucp_ep_attr_field(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucp_ep_attr_field {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucp_ep_attr_field) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ucp_ep_attr_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucp_ep_attr {
    pub field_mask: u64,
    pub name: [::std::os::raw::c_char; 32usize],
    pub local_sockaddr: sockaddr_storage,
    pub remote_sockaddr: sockaddr_storage,
    pub transports: ucp_transports_t,
}
#[test]
fn bindgen_test_layout_ucp_ep_attr() {
    const UNINIT: ::std::mem::MaybeUninit<ucp_ep_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucp_ep_attr>(),
        320usize,
        concat!("Size of: ", stringify!(ucp_ep_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ucp_ep_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ucp_ep_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_attr),
            "::",
            stringify!(field_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_attr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sockaddr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_attr),
            "::",
            stringify!(local_sockaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_sockaddr) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_attr),
            "::",
            stringify!(remote_sockaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transports) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucp_ep_attr),
            "::",
            stringify!(transports)
        )
    );
}
pub type ucp_ep_attr_t = ucp_ep_attr;
extern "C" {
    pub fn ucp_ep_query(ep: ucp_ep_h, attr: *mut ucp_ep_attr_t) -> ucs_status_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucm_event_type {
    UCM_EVENT_NONE = 0,
    UCM_EVENT_MMAP = 1,
    UCM_EVENT_MUNMAP = 2,
    UCM_EVENT_MREMAP = 4,
    UCM_EVENT_SHMAT = 8,
    UCM_EVENT_SHMDT = 16,
    UCM_EVENT_SBRK = 32,
    UCM_EVENT_MADVISE = 64,
    UCM_EVENT_BRK = 128,
    UCM_EVENT_VM_MAPPED = 65536,
    UCM_EVENT_VM_UNMAPPED = 131072,
    UCM_EVENT_MEM_TYPE_ALLOC = 1048576,
    UCM_EVENT_MEM_TYPE_FREE = 2097152,
    UCM_EVENT_FLAG_NO_INSTALL = 16777216,
    UCM_EVENT_FLAG_EXISTING_ALLOC = 33554432,
}
pub use self::ucm_event_type as ucm_event_type_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucm_mmap_hook_mode {
    UCM_MMAP_HOOK_NONE = 0,
    UCM_MMAP_HOOK_RELOC = 1,
    UCM_MMAP_HOOK_BISTRO = 2,
    UCM_MMAP_HOOK_LAST = 3,
}
pub use self::ucm_mmap_hook_mode as ucm_mmap_hook_mode_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ucm_module_unload_prevent_mode {
    UCM_UNLOAD_PREVENT_MODE_LAZY = 0,
    UCM_UNLOAD_PREVENT_MODE_NOW = 1,
    UCM_UNLOAD_PREVENT_MODE_NONE = 2,
    UCM_UNLOAD_PREVENT_MODE_LAST = 3,
}
pub use self::ucm_module_unload_prevent_mode as ucm_module_unload_prevent_mode_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ucm_event {
    pub mmap: ucm_event__bindgen_ty_1,
    pub munmap: ucm_event__bindgen_ty_2,
    pub mremap: ucm_event__bindgen_ty_3,
    pub shmat: ucm_event__bindgen_ty_4,
    pub shmdt: ucm_event__bindgen_ty_5,
    pub sbrk: ucm_event__bindgen_ty_6,
    pub madvise: ucm_event__bindgen_ty_7,
    pub brk: ucm_event__bindgen_ty_8,
    pub vm_mapped: ucm_event__bindgen_ty_9,
    pub vm_unmapped: ucm_event__bindgen_ty_9,
    pub mem_type: ucm_event__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_1 {
    pub result: *mut ::std::os::raw::c_void,
    pub address: *mut ::std::os::raw::c_void,
    pub size: usize,
    pub prot: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub fd: ::std::os::raw::c_int,
    pub offset: off_t,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_1),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_1),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_1),
            "::",
            stringify!(prot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_2 {
    pub result: ::std::os::raw::c_int,
    pub address: *mut ::std::os::raw::c_void,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_2),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_2),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_3 {
    pub result: *mut ::std::os::raw::c_void,
    pub address: *mut ::std::os::raw::c_void,
    pub old_size: usize,
    pub new_size: usize,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_3>(),
        40usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_3),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_3),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_3),
            "::",
            stringify!(old_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_3),
            "::",
            stringify!(new_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_3),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_4 {
    pub result: *mut ::std::os::raw::c_void,
    pub shmid: ::std::os::raw::c_int,
    pub shmaddr: *const ::std::os::raw::c_void,
    pub shmflg: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_4),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_4),
            "::",
            stringify!(shmid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmaddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_4),
            "::",
            stringify!(shmaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmflg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_4),
            "::",
            stringify!(shmflg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_5 {
    pub result: ::std::os::raw::c_int,
    pub shmaddr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_5),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_5),
            "::",
            stringify!(shmaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_6 {
    pub result: *mut ::std::os::raw::c_void,
    pub increment: isize,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_6),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).increment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_6),
            "::",
            stringify!(increment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_7 {
    pub result: ::std::os::raw::c_int,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub advice: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_7>(),
        32usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_7),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_7),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_7),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advice) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_7),
            "::",
            stringify!(advice)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_8 {
    pub result: ::std::os::raw::c_int,
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_8() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_8> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_8>(),
        16usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_8>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_8),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_8),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_9 {
    pub address: *mut ::std::os::raw::c_void,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_9() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_9> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_9>(),
        16usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_9>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_9))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_9),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_9),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_event__bindgen_ty_10 {
    pub address: *mut ::std::os::raw::c_void,
    pub size: usize,
    pub mem_type: ucs_memory_type_t,
}
#[test]
fn bindgen_test_layout_ucm_event__bindgen_ty_10() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event__bindgen_ty_10> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event__bindgen_ty_10>(),
        24usize,
        concat!("Size of: ", stringify!(ucm_event__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event__bindgen_ty_10>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event__bindgen_ty_10))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_10),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_10),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event__bindgen_ty_10),
            "::",
            stringify!(mem_type)
        )
    );
}
#[test]
fn bindgen_test_layout_ucm_event() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_event>(),
        48usize,
        concat!("Size of: ", stringify!(ucm_event))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_event>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).munmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(munmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mremap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(mremap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(shmat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmdt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(shmdt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbrk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(sbrk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).madvise) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(madvise)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(brk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vm_mapped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(vm_mapped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vm_unmapped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(vm_unmapped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_event),
            "::",
            stringify!(mem_type)
        )
    );
}
pub type ucm_event_t = ucm_event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucm_global_config {
    pub log_level: ucs_log_level_t,
    pub enable_events: ::std::os::raw::c_int,
    pub mmap_hook_mode: ucm_mmap_hook_mode_t,
    pub enable_malloc_hooks: ::std::os::raw::c_int,
    pub enable_malloc_reloc: ::std::os::raw::c_int,
    pub cuda_hook_modes: ::std::os::raw::c_int,
    pub enable_dynamic_mmap_thresh: ::std::os::raw::c_int,
    pub alloc_alignment: usize,
    pub dlopen_process_rpath: ::std::os::raw::c_int,
    pub module_unload_prevent_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ucm_global_config() {
    const UNINIT: ::std::mem::MaybeUninit<ucm_global_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucm_global_config>(),
        48usize,
        concat!("Size of: ", stringify!(ucm_global_config))
    );
    assert_eq!(
        ::std::mem::align_of::<ucm_global_config>(),
        8usize,
        concat!("Alignment of ", stringify!(ucm_global_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(enable_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap_hook_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(mmap_hook_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_malloc_hooks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(enable_malloc_hooks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_malloc_reloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(enable_malloc_reloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cuda_hook_modes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(cuda_hook_modes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_dynamic_mmap_thresh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(enable_dynamic_mmap_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_alignment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(alloc_alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlopen_process_rpath) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(dlopen_process_rpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_unload_prevent_mode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ucm_global_config),
            "::",
            stringify!(module_unload_prevent_mode)
        )
    );
}
pub type ucm_global_config_t = ucm_global_config;
extern "C" {
    pub static mut ucm_global_opts: ucm_global_config_t;
}
pub type ucm_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: ucm_event_type_t,
        event: *mut ucm_event_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn ucm_set_global_opts(ucm_opts: *const ucm_global_config_t);
}
extern "C" {
    pub fn ucm_set_event_handler(
        events: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        cb: ucm_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ucs_status_t;
}
extern "C" {
    pub fn ucm_unset_event_handler(
        events: ::std::os::raw::c_int,
        cb: ucm_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ucm_set_external_event(events: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ucm_unset_external_event(events: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ucm_test_events(events: ::std::os::raw::c_int) -> ucs_status_t;
}
extern "C" {
    pub fn ucm_test_external_events(events: ::std::os::raw::c_int) -> ucs_status_t;
}
extern "C" {
    pub fn ucm_orig_mmap(
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        prot: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        offset: off_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_orig_munmap(
        addr: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_orig_mremap(
        old_address: *mut ::std::os::raw::c_void,
        old_size: usize,
        new_size: usize,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_orig_shmat(
        shmid: ::std::os::raw::c_int,
        shmaddr: *const ::std::os::raw::c_void,
        shmflg: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_orig_shmdt(shmaddr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_orig_sbrk(increment: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_orig_brk(addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_orig_madvise(
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        advice: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_mmap(
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        prot: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        offset: off_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_munmap(addr: *mut ::std::os::raw::c_void, length: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_vm_mmap(addr: *mut ::std::os::raw::c_void, length: usize);
}
extern "C" {
    pub fn ucm_vm_munmap(addr: *mut ::std::os::raw::c_void, length: usize);
}
extern "C" {
    pub fn ucm_mremap(
        old_address: *mut ::std::os::raw::c_void,
        old_size: usize,
        new_size: usize,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_shmat(
        shmid: ::std::os::raw::c_int,
        shmaddr: *const ::std::os::raw::c_void,
        shmflg: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_shmdt(shmaddr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_sbrk(increment: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ucm_brk(addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_madvise(
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        advice: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucm_dlopen(
        filename: *const ::std::os::raw::c_char,
        flag: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
